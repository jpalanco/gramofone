Date: Thu, 18 Apr 2013 16:31:25 -0700
Subject: [PATCH] Add bootstrap patch

Signed-off-by: Mathieu Olivari <mathieu@qca.qualcomm.com>
---
 lib_bootstrap/LzmaDecode.c             |  622 +++++++++++++++++++++++++++
 lib_bootstrap/LzmaDecode.h             |  113 +++++
 lib_bootstrap/LzmaTypes.h              |   45 ++
 lib_bootstrap/LzmaWrapper.c            |  223 ++++++++++
 lib_bootstrap/Makefile                 |   52 +++
 lib_bootstrap/console.c                |  573 +++++++++++++++++++++++++
 lib_bootstrap/crc32.c                  |  197 +++++++++
 lib_bootstrap/ctype.c                  |   56 +++
 lib_bootstrap/devices.c                |  216 ++++++++++
 lib_bootstrap/display_options.c        |   67 +++
 lib_bootstrap/lists.c                  |  734 ++++++++++++++++++++++++++++++++
 lib_bootstrap/string.c                 |  578 +++++++++++++++++++++++++
 lib_bootstrap/time.c                   |   99 +++++
 lib_bootstrap/vsprintf.c               |  385 +++++++++++++++++
 15 files changed, 4461 insertions(+)
 create mode 100644 lib_bootstrap/LzmaDecode.c
 create mode 100644 lib_bootstrap/LzmaDecode.h
 create mode 100644 lib_bootstrap/LzmaTypes.h
 create mode 100644 lib_bootstrap/LzmaWrapper.c
 create mode 100644 lib_bootstrap/Makefile
 create mode 100644 lib_bootstrap/console.c
 create mode 100644 lib_bootstrap/crc32.c
 create mode 100644 lib_bootstrap/ctype.c
 create mode 100644 lib_bootstrap/devices.c
 create mode 100644 lib_bootstrap/display_options.c
 create mode 100644 lib_bootstrap/lists.c
 create mode 100644 lib_bootstrap/string.c
 create mode 100644 lib_bootstrap/time.c
 create mode 100644 lib_bootstrap/vsprintf.c

--- /dev/null
+++ b/lib_bootstrap/LzmaDecode.c
@@ -0,0 +1,622 @@
+/*
+  LzmaDecode.c
+  LZMA Decoder (optimized for Speed version)
+  
+  LZMA SDK 4.40 Copyright (c) 1999-2006 Igor Pavlov (2006-05-01)
+  http://www.7-zip.org/
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this Code, expressly permits you to 
+  statically or dynamically link your Code (or bind by name) to the 
+  interfaces of this file without subjecting your linked Code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#ifdef CONFIG_LZMA
+
+#include "LzmaDecode.h"
+
+#define kNumTopBits 24
+#define kTopValue ((UInt32)1 << kNumTopBits)
+
+#define kNumBitModelTotalBits 11
+#define kBitModelTotal (1 << kNumBitModelTotalBits)
+#define kNumMoveBits 5
+
+#define RC_READ_BYTE (*Buffer++)
+
+#define RC_INIT2 Code = 0; Range = 0xFFFFFFFF; \
+  { int i; for(i = 0; i < 5; i++) { RC_TEST; Code = (Code << 8) | RC_READ_BYTE; }}
+
+#ifdef _LZMA_IN_CB
+
+
+#if 0
+#define RC_TEST { if (Buffer == BufferLim) \
+  { SizeT size; int result = InCallback->Read(InCallback, &Buffer, &size); if (result != LZMA_RESULT_OK) { printf("ERROR, %s, %d\n", __FILE__, __LINE__); return result; } \
+  BufferLim = Buffer + size; if (size == 0) { printf("ERROR, %s, %d\n", __FILE__, __LINE__); return LZMA_RESULT_DATA_ERROR; } }}
+#else
+
+#define RC_TEST { if (Buffer == BufferLim) \
+  { SizeT size; int result = InCallback->Read(InCallback, &Buffer, &size); if (result != LZMA_RESULT_OK) { return result; } \
+  BufferLim = Buffer + size; if (size == 0) { return LZMA_RESULT_DATA_ERROR; } }}
+#endif
+
+#define RC_INIT Buffer = BufferLim = 0; RC_INIT2
+
+#else
+
+#if 0
+#define RC_TEST { if (Buffer == BufferLim) { printf("ERROR, %s, %d\n", __FILE__, __LINE__); return LZMA_RESULT_DATA_ERROR; } }
+#else
+#define RC_TEST { if (Buffer == BufferLim) { return LZMA_RESULT_DATA_ERROR; } }
+#endif
+
+#define RC_INIT(buffer, bufferSize) Buffer = buffer; BufferLim = buffer + bufferSize; RC_INIT2
+ 
+#endif
+
+#define RC_NORMALIZE if (Range < kTopValue) { RC_TEST; Range <<= 8; Code = (Code << 8) | RC_READ_BYTE; }
+
+#define IfBit0(p) RC_NORMALIZE; bound = (Range >> kNumBitModelTotalBits) * *(p); if (Code < bound)
+#define UpdateBit0(p) Range = bound; *(p) += (kBitModelTotal - *(p)) >> kNumMoveBits;
+#define UpdateBit1(p) Range -= bound; Code -= bound; *(p) -= (*(p)) >> kNumMoveBits;
+
+#define RC_GET_BIT2(p, mi, A0, A1) IfBit0(p) \
+  { UpdateBit0(p); mi <<= 1; A0; } else \
+  { UpdateBit1(p); mi = (mi + mi) + 1; A1; } 
+  
+#define RC_GET_BIT(p, mi) RC_GET_BIT2(p, mi, ; , ;)               
+
+#define RangeDecoderBitTreeDecode(probs, numLevels, res) \
+  { int i = numLevels; res = 1; \
+  do { CProb *p = probs + res; RC_GET_BIT(p, res) } while(--i != 0); \
+  res -= (1 << numLevels); }
+
+
+#define kNumPosBitsMax 4
+#define kNumPosStatesMax (1 << kNumPosBitsMax)
+
+#define kLenNumLowBits 3
+#define kLenNumLowSymbols (1 << kLenNumLowBits)
+#define kLenNumMidBits 3
+#define kLenNumMidSymbols (1 << kLenNumMidBits)
+#define kLenNumHighBits 8
+#define kLenNumHighSymbols (1 << kLenNumHighBits)
+
+#define LenChoice 0
+#define LenChoice2 (LenChoice + 1)
+#define LenLow (LenChoice2 + 1)
+#define LenMid (LenLow + (kNumPosStatesMax << kLenNumLowBits))
+#define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
+#define kNumLenProbs (LenHigh + kLenNumHighSymbols) 
+
+
+#define kNumStates 12
+#define kNumLitStates 7
+
+#define kStartPosModelIndex 4
+#define kEndPosModelIndex 14
+#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))
+
+#define kNumPosSlotBits 6
+#define kNumLenToPosStates 4
+
+#define kNumAlignBits 4
+#define kAlignTableSize (1 << kNumAlignBits)
+
+#define kMatchMinLen 2
+
+#define IsMatch 0
+#define IsRep (IsMatch + (kNumStates << kNumPosBitsMax))
+#define IsRepG0 (IsRep + kNumStates)
+#define IsRepG1 (IsRepG0 + kNumStates)
+#define IsRepG2 (IsRepG1 + kNumStates)
+#define IsRep0Long (IsRepG2 + kNumStates)
+#define PosSlot (IsRep0Long + (kNumStates << kNumPosBitsMax))
+#define SpecPos (PosSlot + (kNumLenToPosStates << kNumPosSlotBits))
+#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
+#define LenCoder (Align + kAlignTableSize)
+#define RepLenCoder (LenCoder + kNumLenProbs)
+#define Literal (RepLenCoder + kNumLenProbs)
+
+#if Literal != LZMA_BASE_SIZE
+StopCompilingDueBUG
+#endif
+
+int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size)
+{
+  unsigned char prop0;
+  if (size < LZMA_PROPERTIES_SIZE)
+  {
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+    printf("ERROR: %s, %d\n", __FILE__, __LINE__);
+#endif
+    return LZMA_RESULT_DATA_ERROR;
+  }
+  prop0 = propsData[0];
+  if (prop0 >= (9 * 5 * 5))
+  {
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+    printf("ERROR: %s, %d\n", __FILE__, __LINE__);
+#endif
+    return LZMA_RESULT_DATA_ERROR;
+  }
+  {
+    for (propsRes->pb = 0; prop0 >= (9 * 5); propsRes->pb++, prop0 -= (9 * 5));
+    for (propsRes->lp = 0; prop0 >= 9; propsRes->lp++, prop0 -= 9);
+    propsRes->lc = prop0;
+    /*
+    unsigned char remainder = (unsigned char)(prop0 / 9);
+    propsRes->lc = prop0 % 9;
+    propsRes->pb = remainder / 5;
+    propsRes->lp = remainder % 5;
+    */
+  }
+
+  #ifdef _LZMA_OUT_READ
+  {
+    int i;
+    propsRes->DictionarySize = 0;
+    for (i = 0; i < 4; i++)
+      propsRes->DictionarySize += (UInt32)(propsData[1 + i]) << (i * 8);
+    if (propsRes->DictionarySize == 0)
+      propsRes->DictionarySize = 1;
+  }
+  #endif
+  return LZMA_RESULT_OK;
+}
+
+#define kLzmaStreamWasFinishedId (-1)
+
+int LzmaDecode(CLzmaDecoderState *vs,
+    #ifdef _LZMA_IN_CB
+    ILzmaInCallback *InCallback,
+    #else
+    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
+    #endif
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed)
+{
+  CProb *p = vs->Probs;
+  SizeT nowPos = 0;
+  Byte previousByte = 0;
+  UInt32 posStateMask = (1 << (vs->Properties.pb)) - 1;
+  UInt32 literalPosMask = (1 << (vs->Properties.lp)) - 1;
+  int lc = vs->Properties.lc;
+
+  #ifdef _LZMA_OUT_READ
+  
+  UInt32 Range = vs->Range;
+  UInt32 Code = vs->Code;
+  #ifdef _LZMA_IN_CB
+  const Byte *Buffer = vs->Buffer;
+  const Byte *BufferLim = vs->BufferLim;
+  #else
+  const Byte *Buffer = inStream;
+  const Byte *BufferLim = inStream + inSize;
+  #endif
+  int state = vs->State;
+  UInt32 rep0 = vs->Reps[0], rep1 = vs->Reps[1], rep2 = vs->Reps[2], rep3 = vs->Reps[3];
+  int len = vs->RemainLen;
+  UInt32 globalPos = vs->GlobalPos;
+  UInt32 distanceLimit = vs->DistanceLimit;
+
+  Byte *dictionary = vs->Dictionary;
+  UInt32 dictionarySize = vs->Properties.DictionarySize;
+  UInt32 dictionaryPos = vs->DictionaryPos;
+
+  Byte tempDictionary[4];
+
+  #ifndef _LZMA_IN_CB
+  *inSizeProcessed = 0;
+  #endif
+  *outSizeProcessed = 0;
+  if (len == kLzmaStreamWasFinishedId)
+    return LZMA_RESULT_OK;
+
+  if (dictionarySize == 0)
+  {
+    dictionary = tempDictionary;
+    dictionarySize = 1;
+    tempDictionary[0] = vs->TempDictionary[0];
+  }
+
+  if (len == kLzmaNeedInitId)
+  {
+    {
+      UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
+      UInt32 i;
+      for (i = 0; i < numProbs; i++)
+        p[i] = kBitModelTotal >> 1; 
+      rep0 = rep1 = rep2 = rep3 = 1;
+      state = 0;
+      globalPos = 0;
+      distanceLimit = 0;
+      dictionaryPos = 0;
+      dictionary[dictionarySize - 1] = 0;
+      #ifdef _LZMA_IN_CB
+      RC_INIT;
+      #else
+      RC_INIT(inStream, inSize);
+      #endif
+    }
+    len = 0;
+  }
+  while(len != 0 && nowPos < outSize)
+  {
+    UInt32 pos = dictionaryPos - rep0;
+    if (pos >= dictionarySize)
+      pos += dictionarySize;
+    outStream[nowPos++] = dictionary[dictionaryPos] = dictionary[pos];
+    if (++dictionaryPos == dictionarySize)
+      dictionaryPos = 0;
+    len--;
+  }
+  if (dictionaryPos == 0)
+    previousByte = dictionary[dictionarySize - 1];
+  else
+    previousByte = dictionary[dictionaryPos - 1];
+
+  #else /* if !_LZMA_OUT_READ */
+
+  int state = 0;
+  UInt32 rep0 = 1, rep1 = 1, rep2 = 1, rep3 = 1;
+  int len = 0;
+  const Byte *Buffer;
+  const Byte *BufferLim;
+  UInt32 Range;
+  UInt32 Code;
+
+  #ifndef _LZMA_IN_CB
+  *inSizeProcessed = 0;
+  #endif
+  *outSizeProcessed = 0;
+
+  {
+    UInt32 i;
+    UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (lc + vs->Properties.lp));
+    for (i = 0; i < numProbs; i++)
+      p[i] = kBitModelTotal >> 1;
+  }
+  
+  #ifdef _LZMA_IN_CB
+  RC_INIT;
+  #else
+  RC_INIT(inStream, inSize);
+  #endif
+
+  #endif /* _LZMA_OUT_READ */
+
+  while(nowPos < outSize)
+  {
+    CProb *prob;
+    UInt32 bound;
+    int posState = (int)(
+        (nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        & posStateMask);
+
+    prob = p + IsMatch + (state << kNumPosBitsMax) + posState;
+    IfBit0(prob)
+    {
+      int symbol = 1;
+      UpdateBit0(prob)
+      prob = p + Literal + (LZMA_LIT_SIZE * 
+        (((
+        (nowPos 
+        #ifdef _LZMA_OUT_READ
+        + globalPos
+        #endif
+        )
+        & literalPosMask) << lc) + (previousByte >> (8 - lc))));
+
+      if (state >= kNumLitStates)
+      {
+        int matchByte;
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos >= dictionarySize)
+          pos += dictionarySize;
+        matchByte = dictionary[pos];
+        #else
+        matchByte = outStream[nowPos - rep0];
+        #endif
+        do
+        {
+          int bit;
+          CProb *probLit;
+          matchByte <<= 1;
+          bit = (matchByte & 0x100);
+          probLit = prob + 0x100 + bit + symbol;
+          RC_GET_BIT2(probLit, symbol, if (bit != 0) break, if (bit == 0) break)
+        }
+        while (symbol < 0x100);
+      }
+      while (symbol < 0x100)
+      {
+        CProb *probLit = prob + symbol;
+        RC_GET_BIT(probLit, symbol)
+      }
+      previousByte = (Byte)symbol;
+
+      outStream[nowPos++] = previousByte;
+      #ifdef _LZMA_OUT_READ
+      if (distanceLimit < dictionarySize)
+        distanceLimit++;
+
+      dictionary[dictionaryPos] = previousByte;
+      if (++dictionaryPos == dictionarySize)
+        dictionaryPos = 0;
+      #endif
+      if (state < 4) state = 0;
+      else if (state < 10) state -= 3;
+      else state -= 6;
+    }
+    else             
+    {
+      UpdateBit1(prob);
+      prob = p + IsRep + state;
+      IfBit0(prob)
+      {
+        UpdateBit0(prob);
+        rep3 = rep2;
+        rep2 = rep1;
+        rep1 = rep0;
+        state = state < kNumLitStates ? 0 : 3;
+        prob = p + LenCoder;
+      }
+      else
+      {
+        UpdateBit1(prob);
+        prob = p + IsRepG0 + state;
+        IfBit0(prob)
+        {
+          UpdateBit0(prob);
+          prob = p + IsRep0Long + (state << kNumPosBitsMax) + posState;
+          IfBit0(prob)
+          {
+            #ifdef _LZMA_OUT_READ
+            UInt32 pos;
+            #endif
+            UpdateBit0(prob);
+            
+            #ifdef _LZMA_OUT_READ
+            if (distanceLimit == 0)
+            #else
+            if (nowPos == 0)
+            #endif
+            {
+			  
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+              printf("ERROR: %s, %d\n", __FILE__, __LINE__);
+#endif
+              return LZMA_RESULT_DATA_ERROR;
+            }
+            
+            state = state < kNumLitStates ? 9 : 11;
+            #ifdef _LZMA_OUT_READ
+            pos = dictionaryPos - rep0;
+            if (pos >= dictionarySize)
+              pos += dictionarySize;
+            previousByte = dictionary[pos];
+            dictionary[dictionaryPos] = previousByte;
+            if (++dictionaryPos == dictionarySize)
+              dictionaryPos = 0;
+            #else
+            previousByte = outStream[nowPos - rep0];
+            #endif
+            outStream[nowPos++] = previousByte;
+            #ifdef _LZMA_OUT_READ
+            if (distanceLimit < dictionarySize)
+              distanceLimit++;
+            #endif
+
+            continue;
+          }
+          else
+          {
+            UpdateBit1(prob);
+          }
+        }
+        else
+        {
+          UInt32 distance;
+          UpdateBit1(prob);
+          prob = p + IsRepG1 + state;
+          IfBit0(prob)
+          {
+            UpdateBit0(prob);
+            distance = rep1;
+          }
+          else 
+          {
+            UpdateBit1(prob);
+            prob = p + IsRepG2 + state;
+            IfBit0(prob)
+            {
+              UpdateBit0(prob);
+              distance = rep2;
+            }
+            else
+            {
+              UpdateBit1(prob);
+              distance = rep3;
+              rep3 = rep2;
+            }
+            rep2 = rep1;
+          }
+          rep1 = rep0;
+          rep0 = distance;
+        }
+        state = state < kNumLitStates ? 8 : 11;
+        prob = p + RepLenCoder;
+      }
+      {
+        int numBits, offset;
+        CProb *probLen = prob + LenChoice;
+        IfBit0(probLen)
+        {
+          UpdateBit0(probLen);
+          probLen = prob + LenLow + (posState << kLenNumLowBits);
+          offset = 0;
+          numBits = kLenNumLowBits;
+        }
+        else
+        {
+          UpdateBit1(probLen);
+          probLen = prob + LenChoice2;
+          IfBit0(probLen)
+          {
+            UpdateBit0(probLen);
+            probLen = prob + LenMid + (posState << kLenNumMidBits);
+            offset = kLenNumLowSymbols;
+            numBits = kLenNumMidBits;
+          }
+          else
+          {
+            UpdateBit1(probLen);
+            probLen = prob + LenHigh;
+            offset = kLenNumLowSymbols + kLenNumMidSymbols;
+            numBits = kLenNumHighBits;
+          }
+        }
+        RangeDecoderBitTreeDecode(probLen, numBits, len);
+        len += offset;
+      }
+
+      if (state < 4)
+      {
+        int posSlot;
+        state += kNumLitStates;
+        prob = p + PosSlot +
+            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << 
+            kNumPosSlotBits);
+        RangeDecoderBitTreeDecode(prob, kNumPosSlotBits, posSlot);
+        if (posSlot >= kStartPosModelIndex)
+        {
+          int numDirectBits = ((posSlot >> 1) - 1);
+          rep0 = (2 | ((UInt32)posSlot & 1));
+          if (posSlot < kEndPosModelIndex)
+          {
+            rep0 <<= numDirectBits;
+            prob = p + SpecPos + rep0 - posSlot - 1;
+          }
+          else
+          {
+            numDirectBits -= kNumAlignBits;
+            do
+            {
+              RC_NORMALIZE
+              Range >>= 1;
+              rep0 <<= 1;
+              if (Code >= Range)
+              {
+                Code -= Range;
+                rep0 |= 1;
+              }
+            }
+            while (--numDirectBits != 0);
+            prob = p + Align;
+            rep0 <<= kNumAlignBits;
+            numDirectBits = kNumAlignBits;
+          }
+          {
+            int i = 1;
+            int mi = 1;
+            do
+            {
+              CProb *prob3 = prob + mi;
+              RC_GET_BIT2(prob3, mi, ; , rep0 |= i);
+              i <<= 1;
+            }
+            while(--numDirectBits != 0);
+          }
+        }
+        else
+          rep0 = posSlot;
+        if (++rep0 == (UInt32)(0))
+        {
+          /* it's for stream version */
+          len = kLzmaStreamWasFinishedId;
+          break;
+        }
+      }
+
+      len += kMatchMinLen;
+      #ifdef _LZMA_OUT_READ
+      if (rep0 > distanceLimit) 
+      #else
+      if (rep0 > nowPos)
+      #endif
+      {
+		
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+        printf("ERROR: %s, %d\n", __FILE__, __LINE__);
+#endif
+        return LZMA_RESULT_DATA_ERROR;
+      }
+
+      #ifdef _LZMA_OUT_READ
+      if (dictionarySize - distanceLimit > (UInt32)len)
+        distanceLimit += len;
+      else
+        distanceLimit = dictionarySize;
+      #endif
+
+      do
+      {
+        #ifdef _LZMA_OUT_READ
+        UInt32 pos = dictionaryPos - rep0;
+        if (pos >= dictionarySize)
+          pos += dictionarySize;
+        previousByte = dictionary[pos];
+        dictionary[dictionaryPos] = previousByte;
+        if (++dictionaryPos == dictionarySize)
+          dictionaryPos = 0;
+        #else
+        previousByte = outStream[nowPos - rep0];
+        #endif
+        len--;
+        outStream[nowPos++] = previousByte;
+      }
+      while(len != 0 && nowPos < outSize);
+    }
+  }
+  RC_NORMALIZE;
+
+  #ifdef _LZMA_OUT_READ
+  vs->Range = Range;
+  vs->Code = Code;
+  vs->DictionaryPos = dictionaryPos;
+  vs->GlobalPos = globalPos + (UInt32)nowPos;
+  vs->DistanceLimit = distanceLimit;
+  vs->Reps[0] = rep0;
+  vs->Reps[1] = rep1;
+  vs->Reps[2] = rep2;
+  vs->Reps[3] = rep3;
+  vs->State = state;
+  vs->RemainLen = len;
+  vs->TempDictionary[0] = tempDictionary[0];
+  #endif
+
+  #ifdef _LZMA_IN_CB
+  vs->Buffer = Buffer;
+  vs->BufferLim = BufferLim;
+  #else
+  *inSizeProcessed = (SizeT)(Buffer - inStream);
+  #endif
+  *outSizeProcessed = nowPos;
+  return LZMA_RESULT_OK;
+}
+
+#endif /* CONFIG_LZMA */
--- /dev/null
+++ b/lib_bootstrap/LzmaDecode.h
@@ -0,0 +1,113 @@
+/* 
+  LzmaDecode.h
+  LZMA Decoder interface
+
+  LZMA SDK 4.40 Copyright (c) 1999-2006 Igor Pavlov (2006-05-01)
+  http://www.7-zip.org/
+
+  LZMA SDK is licensed under two licenses:
+  1) GNU Lesser General Public License (GNU LGPL)
+  2) Common Public License (CPL)
+  It means that you can select one of these two licenses and 
+  follow rules of that license.
+
+  SPECIAL EXCEPTION:
+  Igor Pavlov, as the author of this code, expressly permits you to 
+  statically or dynamically link your code (or bind by name) to the 
+  interfaces of this file without subjecting your linked code to the 
+  terms of the CPL or GNU LGPL. Any modifications or additions 
+  to this file, however, are subject to the LGPL or CPL terms.
+*/
+
+#ifndef __LZMADECODE_H
+#define __LZMADECODE_H
+
+#include "LzmaTypes.h"
+
+/* #define _LZMA_IN_CB */
+/* Use callback for input data */
+
+/* #define _LZMA_OUT_READ */
+/* Use read function for output data */
+
+/* #define _LZMA_PROB32 */
+/* It can increase speed on some 32-bit CPUs, 
+   but memory usage will be doubled in that case */
+
+/* #define _LZMA_LOC_OPT */
+/* Enable local speed optimizations inside code */
+
+#ifdef _LZMA_PROB32
+#define CProb UInt32
+#else
+#define CProb UInt16
+#endif
+
+#define LZMA_RESULT_OK 0
+#define LZMA_RESULT_DATA_ERROR 1
+
+#ifdef _LZMA_IN_CB
+typedef struct _ILzmaInCallback
+{
+  int (*Read)(void *object, const unsigned char **buffer, SizeT *bufferSize);
+} ILzmaInCallback;
+#endif
+
+#define LZMA_BASE_SIZE 1846
+#define LZMA_LIT_SIZE 768
+
+#define LZMA_PROPERTIES_SIZE 5
+
+typedef struct _CLzmaProperties
+{
+  int lc;
+  int lp;
+  int pb;
+  #ifdef _LZMA_OUT_READ
+  UInt32 DictionarySize;
+  #endif
+}CLzmaProperties;
+
+int LzmaDecodeProperties(CLzmaProperties *propsRes, const unsigned char *propsData, int size);
+
+#define LzmaGetNumProbs(Properties) (LZMA_BASE_SIZE + (LZMA_LIT_SIZE << ((Properties)->lc + (Properties)->lp)))
+
+#define kLzmaNeedInitId (-2)
+
+typedef struct _CLzmaDecoderState
+{
+  CLzmaProperties Properties;
+  CProb *Probs;
+
+  #ifdef _LZMA_IN_CB
+  const unsigned char *Buffer;
+  const unsigned char *BufferLim;
+  #endif
+
+  #ifdef _LZMA_OUT_READ
+  unsigned char *Dictionary;
+  UInt32 Range;
+  UInt32 Code;
+  UInt32 DictionaryPos;
+  UInt32 GlobalPos;
+  UInt32 DistanceLimit;
+  UInt32 Reps[4];
+  int State;
+  int RemainLen;
+  unsigned char TempDictionary[4];
+  #endif
+} CLzmaDecoderState;
+
+#ifdef _LZMA_OUT_READ
+#define LzmaDecoderInit(vs) { (vs)->RemainLen = kLzmaNeedInitId; }
+#endif
+
+int LzmaDecode(CLzmaDecoderState *vs,
+    #ifdef _LZMA_IN_CB
+    ILzmaInCallback *inCallback,
+    #else
+    const unsigned char *inStream, SizeT inSize, SizeT *inSizeProcessed,
+    #endif
+    unsigned char *outStream, SizeT outSize, SizeT *outSizeProcessed);
+
+#endif
--- /dev/null
+++ b/lib_bootstrap/LzmaTypes.h
@@ -0,0 +1,45 @@
+/* 
+LzmaTypes.h 
+
+Types for LZMA Decoder
+
+This file written and distributed to public domain by Igor Pavlov.
+This file is part of LZMA SDK 4.40 (2006-05-01)
+*/
+
+#ifndef __LZMATYPES_H
+#define __LZMATYPES_H
+
+#ifndef _7ZIP_BYTE_DEFINED
+#define _7ZIP_BYTE_DEFINED
+typedef unsigned char Byte;
+#endif 
+
+#ifndef _7ZIP_UINT16_DEFINED
+#define _7ZIP_UINT16_DEFINED
+typedef unsigned short UInt16;
+#endif 
+
+#ifndef _7ZIP_UINT32_DEFINED
+#define _7ZIP_UINT32_DEFINED
+#ifdef _LZMA_UINT32_IS_ULONG
+typedef unsigned long UInt32;
+#else
+typedef unsigned int UInt32;
+#endif
+#endif 
+
+/* #define _LZMA_SYSTEM_SIZE_T */
+/* Use system's size_t. You can use it to enable 64-bit sizes supporting */
+
+#ifndef _7ZIP_SIZET_DEFINED
+#define _7ZIP_SIZET_DEFINED
+#ifdef _LZMA_SYSTEM_SIZE_T
+#include <stddef.h>
+typedef size_t SizeT;
+#else
+typedef UInt32 SizeT;
+#endif
+#endif
+
+#endif
--- /dev/null
+++ b/lib_bootstrap/LzmaWrapper.c
@@ -0,0 +1,223 @@
+/******************************************************************************
+**
+** FILE NAME    : LzmaWrapper.c
+** PROJECT      : bootloader
+** MODULES      : U-boot
+**
+** DATE         : 2 Nov 2006
+** AUTHOR       : Lin Mars
+** DESCRIPTION  : LZMA decoder support for U-boot 1.1.5
+** COPYRIGHT    :       Copyright (c) 2006
+**                      Infineon Technologies AG
+**                      Am Campeon 1-12, 85579 Neubiberg, Germany
+**
+**    This program is free software; you can redistribute it and/or modify
+**    it under the terms of the GNU General Public License as published by
+**    the Free Software Foundation; either version 2 of the License, or
+**    (at your option) any later version.
+**
+** HISTORY
+** $Date        $Author         $Comment
+** 2 Nov 2006   Lin Mars        init version which derived from LzmaTest.c from
+**                              LZMA v4.43 SDK
+*******************************************************************************/
+#define LZMA_NO_STDIO
+#ifndef LZMA_NO_STDIO
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#endif
+
+#include <config.h>
+#include <common.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+#include <malloc.h>
+
+#ifdef CONFIG_LZMA
+
+#include "LzmaDecode.h"
+#include "LzmaWrapper.h"
+
+static const char *kCantReadMessage = "Can not read from source buffer";
+static const char *kCantAllocateMessage = "Not enough buffer for decompression";
+
+static size_t rpos=0, dpos=0;
+
+static int MyReadFileAndCheck(unsigned char *src, void *dest, size_t size)
+{
+  if (size == 0)
+    return 0;
+  memcpy(dest, src + rpos, size);
+  rpos += size;
+  return 1;
+}
+
+int lzma_inflate(unsigned char *source, int s_len, unsigned char *dest, int *d_len)
+{
+  /* We use two 32-bit integers to construct 64-bit integer for file size.
+     You can remove outSizeHigh, if you don't need >= 4GB supporting,
+     or you can use UInt64 outSize, if your compiler supports 64-bit integers*/
+  UInt32 outSize = 0;
+  UInt32 outSizeHigh = 0;
+  SizeT outSizeFull;
+  unsigned char *outStream;
+  
+  int waitEOS = 1; 
+  /* waitEOS = 1, if there is no uncompressed size in headers, 
+   so decoder will wait EOS (End of Stream Marker) in compressed stream */
+
+  SizeT compressedSize;
+  unsigned char *inStream;
+
+  CLzmaDecoderState state;  /* it's about 24-80 bytes structure, if int is 32-bit */
+  unsigned char properties[LZMA_PROPERTIES_SIZE];
+
+  int res;
+
+  if (sizeof(UInt32) < 4)
+  {
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+    printf("LZMA decoder needs correct UInt32\n");
+#endif
+    return LZMA_RESULT_DATA_ERROR;
+  }
+
+  {
+    long length=s_len;
+    if ((long)(SizeT)length != length)
+    {
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+      printf("Too big compressed stream\n");
+#endif
+      return LZMA_RESULT_DATA_ERROR;
+    }
+    compressedSize = (SizeT)(length - (LZMA_PROPERTIES_SIZE + 8));
+  }
+
+  /* Read LZMA properties for compressed stream */
+
+  if (!MyReadFileAndCheck(source, properties, sizeof(properties)))
+  {
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+    printf("%s\n", kCantReadMessage);
+#endif
+    return LZMA_RESULT_DATA_ERROR;
+  }
+
+  /* Read uncompressed size */
+  {
+    int i;
+    for (i = 0; i < 8; i++)
+    {
+      unsigned char b;
+      if (!MyReadFileAndCheck(source, &b, 1))
+      {
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+        printf("%s\n", kCantReadMessage);
+#endif
+        return LZMA_RESULT_DATA_ERROR;
+      }
+      if (b != 0xFF)
+        waitEOS = 0;
+      if (i < 4)
+        outSize += (UInt32)(b) << (i * 8);
+      else
+        outSizeHigh += (UInt32)(b) << ((i - 4) * 8);
+    }
+    
+    if (waitEOS)
+    {
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+      printf("Stream with EOS marker is not supported");
+#endif
+      return LZMA_RESULT_DATA_ERROR;
+    }
+    outSizeFull = (SizeT)outSize;
+    if (sizeof(SizeT) >= 8)
+      outSizeFull |= (((SizeT)outSizeHigh << 16) << 16);
+    else if (outSizeHigh != 0 || (UInt32)(SizeT)outSize != outSize)
+    {
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+      printf("Too big uncompressed stream");
+#endif
+      return LZMA_RESULT_DATA_ERROR;
+    }
+  }
+
+  /* Decode LZMA properties and allocate memory */
+  if (LzmaDecodeProperties(&state.Properties, properties, LZMA_PROPERTIES_SIZE) != LZMA_RESULT_OK)
+  {
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+    printf("Incorrect stream properties");
+#endif
+    return LZMA_RESULT_DATA_ERROR;
+  }
+  state.Probs = (CProb *)malloc(LzmaGetNumProbs(&state.Properties) * sizeof(CProb));
+
+  if (outSizeFull == 0)
+    outStream = 0;
+  else
+  {
+    if (outSizeFull > d_len)
+      outStream = 0;
+    else
+      outStream = dest;
+  }
+
+  if (compressedSize == 0)
+    inStream = 0;
+  else
+  {
+    if ((compressedSize+rpos) > s_len )
+      inStream = 0;
+    else
+      inStream = source + rpos;
+  }
+
+  if (state.Probs == 0 
+    || (outStream == 0 && outSizeFull != 0)
+    || (inStream == 0 && compressedSize != 0)
+    )
+  {
+    free(state.Probs);
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+    printf("%s\n", kCantAllocateMessage);
+#endif
+    return LZMA_RESULT_DATA_ERROR;
+  }
+
+  /* Decompress */
+  {
+    SizeT inProcessed;
+    SizeT outProcessed;
+    res = LzmaDecode(&state,
+      inStream, compressedSize, &inProcessed,
+      outStream, outSizeFull, &outProcessed);
+    if (res != 0)
+    {
+
+#ifdef DEBUG_ENABLE_BOOTSTRAP_PRINTF
+      printf("\nDecoding error = %d\n", res);
+#endif
+      res = 1;
+    }
+    else
+    {
+      *d_len = outProcessed;
+    }
+  }
+
+  free(state.Probs);
+  return res;
+}
+
+#endif /* CONFIG_LZMA */
--- /dev/null
+++ b/lib_bootstrap/Makefile
@@ -0,0 +1,52 @@
+#
+# (C) Copyright 2003
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= libbootstrap.a
+
+#OBJS_PRINTF_ENABLED	= bootstrap_board.o time.o console.o LzmaWrapper.o LzmaDecode.o crc32.o ctype.o display_options.o string.o vsprintf.o lists.o devices.o
+#OBJS_PRINTF_DISBALED	= bootstrap_board.o LzmaDecode.o string.o crc32.o LzmaWrapper.o 
+
+OBJS	= bootstrap_board_$(BOARDDIR).o LzmaDecode.o string.o crc32.o LzmaWrapper.o 
+
+ifeq ($(BOOTSTRAP_PRINTF_STATUS), BOOTSTRAP_PRINTF_ENABLED)
+#overwrite objs
+OBJS	= bootstrap_board_$(BOARDDIR).o time.o console.o LzmaWrapper.o LzmaDecode.o crc32.o ctype.o display_options.o string.o vsprintf.o lists.o devices.o
+CFLAGS += -DDEBUG_ENABLE_BOOTSTRAP_PRINTF
+endif
+
+all:	.depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) crv $@ $(OBJS)
+
+#########################################################################
+
+.depend:	Makefile $(OBJS:.o=.c)
+		echo "make libbootstrap.a with HEAD_SIZE $(HEAD_SIZE)"
+		$(CC) -M $(CFLAGS) $(OBJS:.o=.c) > $@
+
+sinclude .depend
+
+#########################################################################
--- /dev/null
+++ b/lib_bootstrap/console.c
@@ -0,0 +1,573 @@
+/*
+ * (C) Copyright 2000
+ * Paolo Scaffardi, AIRVENT SAM s.p.a - RIMINI(ITALY), arsenio@tin.it
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <stdarg.h>
+#include <malloc.h>
+#include <console.h>
+#include <exports.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#ifdef CONFIG_AMIGAONEG3SE
+int console_changed = 0;
+#endif
+
+#ifdef CFG_CONSOLE_IS_IN_ENV
+/*
+ * if overwrite_console returns 1, the stdin, stderr and stdout
+ * are switched to the serial port, else the settings in the
+ * environment are used
+ */
+#ifdef CFG_CONSOLE_OVERWRITE_ROUTINE
+extern int overwrite_console (void);
+#define OVERWRITE_CONSOLE overwrite_console ()
+#else
+#define OVERWRITE_CONSOLE 0
+#endif /* CFG_CONSOLE_OVERWRITE_ROUTINE */
+
+#endif /* CFG_CONSOLE_IS_IN_ENV */
+
+static int console_setfile (int file, device_t * dev)
+{
+	int error = 0;
+
+	if (dev == NULL)
+		return -1;
+
+	switch (file) {
+	case stdin:
+	case stdout:
+	case stderr:
+		/* Start new device */
+		if (dev->start) {
+			error = dev->start ();
+			/* If it's not started dont use it */
+			if (error < 0)
+				break;
+		}
+
+		/* Assign the new device (leaving the existing one started) */
+		stdio_devices[file] = dev;
+
+		/*
+		 * Update monitor functions
+		 * (to use the console stuff by other applications)
+		 */
+		switch (file) {
+		case stdin:
+			gd->jt[XF_getc] = dev->getc;
+			gd->jt[XF_tstc] = dev->tstc;
+			break;
+		case stdout:
+			gd->jt[XF_putc] = dev->putc;
+			gd->jt[XF_puts] = dev->puts;
+			gd->jt[XF_printf] = printf;
+			break;
+		}
+		break;
+
+	default:		/* Invalid file ID */
+		error = -1;
+	}
+	return error;
+}
+
+/** U-Boot INITIAL CONSOLE-NOT COMPATIBLE FUNCTIONS *************************/
+
+void serial_printf (const char *fmt, ...)
+{
+	va_list args;
+	uint i;
+	char printbuffer[CFG_PBSIZE];
+
+	va_start (args, fmt);
+
+	/* For this to work, printbuffer must be larger than
+	 * anything we ever want to print.
+	 */
+	i = vsprintf (printbuffer, fmt, args);
+	va_end (args);
+
+	serial_puts (printbuffer);
+}
+
+int fgetc (int file)
+{
+	if (file < MAX_FILES)
+		return stdio_devices[file]->getc ();
+
+	return -1;
+}
+
+int ftstc (int file)
+{
+	if (file < MAX_FILES)
+		return stdio_devices[file]->tstc ();
+
+	return -1;
+}
+
+void fputc (int file, const char c)
+{
+	if (file < MAX_FILES)
+		stdio_devices[file]->putc (c);
+}
+
+void fputs (int file, const char *s)
+{
+	if (file < MAX_FILES)
+		stdio_devices[file]->puts (s);
+}
+
+void fprintf (int file, const char *fmt, ...)
+{
+	va_list args;
+	uint i;
+	char printbuffer[CFG_PBSIZE];
+
+	va_start (args, fmt);
+
+	/* For this to work, printbuffer must be larger than
+	 * anything we ever want to print.
+	 */
+	i = vsprintf (printbuffer, fmt, args);
+	va_end (args);
+
+	/* Send to desired file */
+	fputs (file, printbuffer);
+}
+
+/** U-Boot INITIAL CONSOLE-COMPATIBLE FUNCTION *****************************/
+
+int getc (void)
+{
+	if (gd->flags & GD_FLG_DEVINIT) {
+		/* Get from the standard input */
+		return fgetc (stdin);
+	}
+
+	/* Send directly to the handler */
+	return serial_getc ();
+}
+
+int tstc (void)
+{
+	if (gd->flags & GD_FLG_DEVINIT) {
+		/* Test the standard input */
+		return ftstc (stdin);
+	}
+
+	/* Send directly to the handler */
+	return serial_tstc ();
+}
+
+void putc (const char c)
+{
+#ifdef CONFIG_SILENT_CONSOLE
+	if (gd->flags & GD_FLG_SILENT)
+		return;
+#endif
+
+	if (gd->flags & GD_FLG_DEVINIT) {
+		/* Send to the standard output */
+		fputc (stdout, c);
+	} else {
+		/* Send directly to the handler */
+		serial_putc (c);
+	}
+}
+
+void puts (const char *s)
+{
+#ifdef CONFIG_SILENT_CONSOLE
+	if (gd->flags & GD_FLG_SILENT)
+		return;
+#endif
+
+	if (gd->flags & GD_FLG_DEVINIT) {
+		/* Send to the standard output */
+		fputs (stdout, s);
+	} else {
+		/* Send directly to the handler */
+		serial_puts (s);
+	}
+}
+
+void printf (const char *fmt, ...)
+{
+	va_list args;
+	uint i;
+	char printbuffer[CFG_PBSIZE];
+
+	va_start (args, fmt);
+
+	/* For this to work, printbuffer must be larger than
+	 * anything we ever want to print.
+	 */
+	i = vsprintf (printbuffer, fmt, args);
+	va_end (args);
+
+	/* Print the string */
+	puts (printbuffer);
+}
+
+void vprintf (const char *fmt, va_list args)
+{
+	uint i;
+	char printbuffer[CFG_PBSIZE];
+
+	/* For this to work, printbuffer must be larger than
+	 * anything we ever want to print.
+	 */
+	i = vsprintf (printbuffer, fmt, args);
+
+	/* Print the string */
+	puts (printbuffer);
+}
+
+/* test if ctrl-c was pressed */
+static int ctrlc_disabled = 0;	/* see disable_ctrl() */
+static int ctrlc_was_pressed = 0;
+int ctrlc (void)
+{
+	if (!ctrlc_disabled && gd->have_console) {
+		if (tstc ()) {
+			switch (getc ()) {
+			case 0x03:		/* ^C - Control C */
+				ctrlc_was_pressed = 1;
+				return 1;
+			default:
+				break;
+			}
+		}
+	}
+	return 0;
+}
+
+/* pass 1 to disable ctrlc() checking, 0 to enable.
+ * returns previous state
+ */
+int disable_ctrlc (int disable)
+{
+	int prev = ctrlc_disabled;	/* save previous state */
+
+	ctrlc_disabled = disable;
+	return prev;
+}
+
+int had_ctrlc (void)
+{
+	return ctrlc_was_pressed;
+}
+
+void clear_ctrlc (void)
+{
+	ctrlc_was_pressed = 0;
+}
+
+#ifdef CONFIG_MODEM_SUPPORT_DEBUG
+char	screen[1024];
+char *cursor = screen;
+int once = 0;
+inline void dbg(const char *fmt, ...)
+{
+	va_list	args;
+	uint	i;
+	char	printbuffer[CFG_PBSIZE];
+
+	if (!once) {
+		memset(screen, 0, sizeof(screen));
+		once++;
+	}
+
+	va_start(args, fmt);
+
+	/* For this to work, printbuffer must be larger than
+	 * anything we ever want to print.
+	 */
+	i = vsprintf(printbuffer, fmt, args);
+	va_end(args);
+
+	if ((screen + sizeof(screen) - 1 - cursor) < strlen(printbuffer)+1) {
+		memset(screen, 0, sizeof(screen));
+		cursor = screen;
+	}
+	sprintf(cursor, printbuffer);
+	cursor += strlen(printbuffer);
+
+}
+#else
+inline void dbg(const char *fmt, ...)
+{
+}
+#endif
+
+/** U-Boot INIT FUNCTIONS *************************************************/
+
+int console_assign (int file, char *devname)
+{
+	int flag, i;
+
+	/* Check for valid file */
+	switch (file) {
+	case stdin:
+		flag = DEV_FLAGS_INPUT;
+		break;
+	case stdout:
+	case stderr:
+		flag = DEV_FLAGS_OUTPUT;
+		break;
+	default:
+		return -1;
+	}
+
+	/* Check for valid device name */
+
+	for (i = 1; i <= ListNumItems (devlist); i++) {
+		device_t *dev = ListGetPtrToItem (devlist, i);
+
+		if (strcmp (devname, dev->name) == 0) {
+			if (dev->flags & flag)
+				return console_setfile (file, dev);
+
+			return -1;
+		}
+	}
+
+	return -1;
+}
+
+/* Called before relocation - use serial functions */
+int console_init_f (void)
+{
+	gd->have_console = 1;
+
+#ifdef CONFIG_SILENT_CONSOLE
+	if (getenv("silent") != NULL)
+		gd->flags |= GD_FLG_SILENT;
+#endif
+
+	return (0);
+}
+
+#if defined(CFG_CONSOLE_IS_IN_ENV) || defined(CONFIG_SPLASH_SCREEN) || defined(CONFIG_SILENT_CONSOLE)
+/* search a device */
+device_t *search_device (int flags, char *name)
+{
+	int i, items;
+	device_t *dev = NULL;
+
+	items = ListNumItems (devlist);
+	if (name == NULL)
+		return dev;
+
+	for (i = 1; i <= items; i++) {
+		dev = ListGetPtrToItem (devlist, i);
+		if ((dev->flags & flags) && (strcmp (name, dev->name) == 0)) {
+			break;
+		}
+	}
+	return dev;
+}
+#endif /* CFG_CONSOLE_IS_IN_ENV || CONFIG_SPLASH_SCREEN */
+
+#ifdef CFG_CONSOLE_IS_IN_ENV
+/* Called after the relocation - use desired console functions */
+int console_init_r (void)
+{
+	char *stdinname, *stdoutname, *stderrname;
+	device_t *inputdev = NULL, *outputdev = NULL, *errdev = NULL;
+#ifdef CFG_CONSOLE_ENV_OVERWRITE
+	int i;
+#endif /* CFG_CONSOLE_ENV_OVERWRITE */
+
+	/* set default handlers at first */
+	gd->jt[XF_getc] = serial_getc;
+	gd->jt[XF_tstc] = serial_tstc;
+	gd->jt[XF_putc] = serial_putc;
+	gd->jt[XF_puts] = serial_puts;
+	gd->jt[XF_printf] = serial_printf;
+
+	/* stdin stdout and stderr are in environment */
+	/* scan for it */
+	stdinname  = getenv ("stdin");
+	stdoutname = getenv ("stdout");
+	stderrname = getenv ("stderr");
+
+	if (OVERWRITE_CONSOLE == 0) { 	/* if not overwritten by config switch */
+		inputdev  = search_device (DEV_FLAGS_INPUT,  stdinname);
+		outputdev = search_device (DEV_FLAGS_OUTPUT, stdoutname);
+		errdev    = search_device (DEV_FLAGS_OUTPUT, stderrname);
+	}
+	/* if the devices are overwritten or not found, use default device */
+	if (inputdev == NULL) {
+		inputdev  = search_device (DEV_FLAGS_INPUT,  "serial");
+	}
+	if (outputdev == NULL) {
+		outputdev = search_device (DEV_FLAGS_OUTPUT, "serial");
+	}
+	if (errdev == NULL) {
+		errdev    = search_device (DEV_FLAGS_OUTPUT, "serial");
+	}
+	/* Initializes output console first */
+	if (outputdev != NULL) {
+		console_setfile (stdout, outputdev);
+	}
+	if (errdev != NULL) {
+		console_setfile (stderr, errdev);
+	}
+	if (inputdev != NULL) {
+		console_setfile (stdin, inputdev);
+	}
+
+	gd->flags |= GD_FLG_DEVINIT;	/* device initialization completed */
+
+#ifndef CFG_CONSOLE_INFO_QUIET
+	/* Print information */
+	puts ("In:    ");
+	if (stdio_devices[stdin] == NULL) {
+		puts ("No input devices available!\n");
+	} else {
+		printf ("%s\n", stdio_devices[stdin]->name);
+	}
+
+	puts ("Out:   ");
+	if (stdio_devices[stdout] == NULL) {
+		puts ("No output devices available!\n");
+	} else {
+		printf ("%s\n", stdio_devices[stdout]->name);
+	}
+
+	puts ("Err:   ");
+	if (stdio_devices[stderr] == NULL) {
+		puts ("No error devices available!\n");
+	} else {
+		printf ("%s\n", stdio_devices[stderr]->name);
+	}
+#endif /* CFG_CONSOLE_INFO_QUIET */
+
+#ifdef CFG_CONSOLE_ENV_OVERWRITE
+	/* set the environment variables (will overwrite previous env settings) */
+	for (i = 0; i < 3; i++) {
+		setenv (stdio_names[i], stdio_devices[i]->name);
+	}
+#endif /* CFG_CONSOLE_ENV_OVERWRITE */
+
+#if 0
+	/* If nothing usable installed, use only the initial console */
+	if ((stdio_devices[stdin] == NULL) && (stdio_devices[stdout] == NULL))
+		return (0);
+#endif
+	return (0);
+}
+
+#else /* CFG_CONSOLE_IS_IN_ENV */
+#if 0
+/* Called after the relocation - use desired console functions */
+int console_init_r (void)
+{
+	device_t *inputdev = NULL, *outputdev = NULL;
+	int i, items = ListNumItems (devlist);
+
+#ifdef CONFIG_SPLASH_SCREEN
+	/* suppress all output if splash screen is enabled and we have
+	   a bmp to display                                            */
+	if (getenv("splashimage") != NULL)
+		outputdev = search_device (DEV_FLAGS_OUTPUT, "nulldev");
+#endif
+
+#ifdef CONFIG_SILENT_CONSOLE
+	/* Suppress all output if "silent" mode requested		*/
+	if (gd->flags & GD_FLG_SILENT)
+		outputdev = search_device (DEV_FLAGS_OUTPUT, "nulldev");
+#endif
+
+	/* Scan devices looking for input and output devices */
+	for (i = 1;
+	     (i <= items) && ((inputdev == NULL) || (outputdev == NULL));
+	     i++
+	    ) {
+		device_t *dev = ListGetPtrToItem (devlist, i);
+
+		if ((dev->flags & DEV_FLAGS_INPUT) && (inputdev == NULL)) {
+			inputdev = dev;
+		}
+		if ((dev->flags & DEV_FLAGS_OUTPUT) && (outputdev == NULL)) {
+			outputdev = dev;
+		}
+	}
+
+	/* Initializes output console first */
+	if (outputdev != NULL) {
+		console_setfile (stdout, outputdev);
+		console_setfile (stderr, outputdev);
+	}
+
+	/* Initializes input console */
+	if (inputdev != NULL) {
+		console_setfile (stdin, inputdev);
+	}
+
+	gd->flags |= GD_FLG_DEVINIT;	/* device initialization completed */
+
+#ifndef CFG_CONSOLE_INFO_QUIET
+	/* Print information */
+	puts ("In:    ");
+	if (stdio_devices[stdin] == NULL) {
+		puts ("No input devices available!\n");
+	} else {
+		printf ("%s\n", stdio_devices[stdin]->name);
+	}
+
+	puts ("Out:   ");
+	if (stdio_devices[stdout] == NULL) {
+		puts ("No output devices available!\n");
+	} else {
+		printf ("%s\n", stdio_devices[stdout]->name);
+	}
+
+	puts ("Err:   ");
+	if (stdio_devices[stderr] == NULL) {
+		puts ("No error devices available!\n");
+	} else {
+		printf ("%s\n", stdio_devices[stderr]->name);
+	}
+#endif /* CFG_CONSOLE_INFO_QUIET */
+
+	/* Setting environment variables */
+	for (i = 0; i < 3; i++) {
+		setenv (stdio_names[i], stdio_devices[i]->name);
+	}
+
+#if 0
+	/* If nothing usable installed, use only the initial console */
+	if ((stdio_devices[stdin] == NULL) && (stdio_devices[stdout] == NULL))
+		return (0);
+#endif
+
+	return (0);
+}
+#endif
+
+#endif /* CFG_CONSOLE_IS_IN_ENV */
--- /dev/null
+++ b/lib_bootstrap/crc32.c
@@ -0,0 +1,197 @@
+/*
+ * This file is derived from crc32.c from the zlib-1.1.3 distribution
+ * by Jean-loup Gailly and Mark Adler.
+ */
+
+/* crc32.c -- compute the CRC-32 of a data stream
+ * Copyright (C) 1995-1998 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+#ifndef USE_HOSTCC	/* Shut down "ANSI does not permit..." warnings */
+#include <common.h>	/* to get command definitions like CFG_CMD_JFFS2 */
+#endif
+
+#include "zlib.h"
+
+#define local static
+#define ZEXPORT	/* empty */
+unsigned long crc32 (unsigned long, const unsigned char *, unsigned int);
+
+#ifdef DYNAMIC_CRC_TABLE
+
+local int crc_table_empty = 1;
+local uLongf crc_table[256];
+local void make_crc_table OF((void));
+
+/*
+  Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
+  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
+
+  Polynomials over GF(2) are represented in binary, one bit per coefficient,
+  with the lowest powers in the most significant bit.  Then adding polynomials
+  is just exclusive-or, and multiplying a polynomial by x is a right shift by
+  one.  If we call the above polynomial p, and represent a byte as the
+  polynomial q, also with the lowest power in the most significant bit (so the
+  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
+  where a mod b means the remainder after dividing a by b.
+
+  This calculation is done using the shift-register method of multiplying and
+  taking the remainder.  The register is initialized to zero, and for each
+  incoming bit, x^32 is added mod p to the register if the bit is a one (where
+  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
+  x (which is shifting right by one and adding x^32 mod p if the bit shifted
+  out is a one).  We start with the highest power (least significant bit) of
+  q and repeat for all eight bits of q.
+
+  The table is simply the CRC of all possible eight bit values.  This is all
+  the information needed to generate CRC's on data a byte at a time for all
+  combinations of CRC register values and incoming bytes.
+*/
+local void make_crc_table()
+{
+  uLong c;
+  int n, k;
+  uLong poly;            /* polynomial exclusive-or pattern */
+  /* terms of polynomial defining this crc (except x^32): */
+  static const Byte p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};
+
+  /* make exclusive-or pattern from polynomial (0xedb88320L) */
+  poly = 0L;
+  for (n = 0; n < sizeof(p)/sizeof(Byte); n++)
+    poly |= 1L << (31 - p[n]);
+
+  for (n = 0; n < 256; n++)
+  {
+    c = (uLong)n;
+    for (k = 0; k < 8; k++)
+      c = c & 1 ? poly ^ (c >> 1) : c >> 1;
+    crc_table[n] = c;
+  }
+  crc_table_empty = 0;
+}
+#else
+/* ========================================================================
+ * Table of CRC-32's of all single-byte values (made by make_crc_table)
+ */
+local const uLongf crc_table[256] = {
+  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
+  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
+  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
+  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
+  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
+  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
+  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
+  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
+  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
+  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
+  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
+  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
+  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
+  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
+  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
+  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
+  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
+  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
+  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
+  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
+  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
+  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
+  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
+  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
+  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
+  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
+  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
+  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
+  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
+  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
+  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
+  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
+  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
+  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
+  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
+  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
+  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
+  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
+  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
+  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
+  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
+  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
+  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
+  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
+  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
+  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
+  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
+  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
+  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
+  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
+  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
+  0x2d02ef8dL
+};
+#endif
+
+#if 0
+/* =========================================================================
+ * This function can be used by asm versions of crc32()
+ */
+const uLongf * ZEXPORT get_crc_table()
+{
+#ifdef DYNAMIC_CRC_TABLE
+  if (crc_table_empty) make_crc_table();
+#endif
+  return (const uLongf *)crc_table;
+}
+#endif
+
+/* ========================================================================= */
+#define DO1(buf) crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);
+#define DO2(buf)  DO1(buf); DO1(buf);
+#define DO4(buf)  DO2(buf); DO2(buf);
+#define DO8(buf)  DO4(buf); DO4(buf);
+
+/* ========================================================================= */
+uLong ZEXPORT crc32(crc, buf, len)
+    uLong crc;
+    const Bytef *buf;
+    uInt len;
+{
+#ifdef DYNAMIC_CRC_TABLE
+    if (crc_table_empty)
+      make_crc_table();
+#endif
+    crc = crc ^ 0xffffffffL;
+    while (len >= 8)
+    {
+      DO8(buf);
+      len -= 8;
+    }
+    if (len) do {
+      DO1(buf);
+    } while (--len);
+    return crc ^ 0xffffffffL;
+}
+
+#if (CONFIG_COMMANDS & CFG_CMD_JFFS2)
+
+/* No ones complement version. JFFS2 (and other things ?)
+ * don't use ones compliment in their CRC calculations.
+ */
+uLong ZEXPORT crc32_no_comp(uLong crc, const Bytef *buf, uInt len)
+{
+#ifdef DYNAMIC_CRC_TABLE
+    if (crc_table_empty)
+      make_crc_table();
+#endif
+    while (len >= 8)
+    {
+      DO8(buf);
+      len -= 8;
+    }
+    if (len) do {
+      DO1(buf);
+    } while (--len);
+
+    return crc;
+}
+
+#endif	/* CFG_CMD_JFFS2 */
--- /dev/null
+++ b/lib_bootstrap/ctype.c
@@ -0,0 +1,56 @@
+/*
+ * (C) Copyright 2000
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ *  linux/lib/ctype.c
+ *
+ *  Copyright (C) 1991, 1992  Linus Torvalds
+ */
+
+#include <linux/ctype.h>
+
+unsigned char _ctype[] = {
+_C,_C,_C,_C,_C,_C,_C,_C,			/* 0-7 */
+_C,_C|_S,_C|_S,_C|_S,_C|_S,_C|_S,_C,_C,		/* 8-15 */
+_C,_C,_C,_C,_C,_C,_C,_C,			/* 16-23 */
+_C,_C,_C,_C,_C,_C,_C,_C,			/* 24-31 */
+_S|_SP,_P,_P,_P,_P,_P,_P,_P,			/* 32-39 */
+_P,_P,_P,_P,_P,_P,_P,_P,			/* 40-47 */
+_D,_D,_D,_D,_D,_D,_D,_D,			/* 48-55 */
+_D,_D,_P,_P,_P,_P,_P,_P,			/* 56-63 */
+_P,_U|_X,_U|_X,_U|_X,_U|_X,_U|_X,_U|_X,_U,	/* 64-71 */
+_U,_U,_U,_U,_U,_U,_U,_U,			/* 72-79 */
+_U,_U,_U,_U,_U,_U,_U,_U,			/* 80-87 */
+_U,_U,_U,_P,_P,_P,_P,_P,			/* 88-95 */
+_P,_L|_X,_L|_X,_L|_X,_L|_X,_L|_X,_L|_X,_L,	/* 96-103 */
+_L,_L,_L,_L,_L,_L,_L,_L,			/* 104-111 */
+_L,_L,_L,_L,_L,_L,_L,_L,			/* 112-119 */
+_L,_L,_L,_P,_P,_P,_P,_C,			/* 120-127 */
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,		/* 128-143 */
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,		/* 144-159 */
+_S|_SP,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,   /* 160-175 */
+_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,_P,       /* 176-191 */
+_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,_U,       /* 192-207 */
+_U,_U,_U,_U,_U,_U,_U,_P,_U,_U,_U,_U,_U,_U,_U,_L,       /* 208-223 */
+_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,_L,       /* 224-239 */
+_L,_L,_L,_L,_L,_L,_L,_P,_L,_L,_L,_L,_L,_L,_L,_L};      /* 240-255 */
--- /dev/null
+++ b/lib_bootstrap/devices.c
@@ -0,0 +1,216 @@
+/*
+ * (C) Copyright 2000
+ * Paolo Scaffardi, AIRVENT SAM s.p.a - RIMINI(ITALY), arsenio@tin.it
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <config.h>
+#include <common.h>
+#include <stdarg.h>
+#include <malloc.h>
+#include <devices.h>
+#include <serial.h>
+#ifdef CONFIG_LOGBUFFER
+#include <logbuff.h>
+#endif
+#if defined(CONFIG_HARD_I2C) || defined(CONFIG_SOFT_I2C)
+#include <i2c.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+list_t devlist = 0;
+device_t *stdio_devices[] = { NULL, NULL, NULL };
+char *stdio_names[MAX_FILES] = { "stdin", "stdout", "stderr" };
+
+#if defined(CONFIG_SPLASH_SCREEN) && !defined(CFG_DEVICE_NULLDEV)
+#define	CFG_DEVICE_NULLDEV	1
+#endif
+
+
+#ifdef CFG_DEVICE_NULLDEV
+void nulldev_putc(const char c)
+{
+  /* nulldev is empty! */
+}
+
+void nulldev_puts(const char *s)
+{
+  /* nulldev is empty! */
+}
+
+int nulldev_input(void)
+{
+  /* nulldev is empty! */
+  return 0;
+}
+#endif
+
+/**************************************************************************
+ * SYSTEM DRIVERS
+ **************************************************************************
+ */
+
+static void drv_system_init (void)
+{
+	device_t dev;
+
+	memset (&dev, 0, sizeof (dev));
+
+	strcpy (dev.name, "serial");
+	dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT | DEV_FLAGS_SYSTEM;
+#ifdef CONFIG_SERIAL_SOFTWARE_FIFO
+	dev.putc = serial_buffered_putc;
+	dev.puts = serial_buffered_puts;
+	dev.getc = serial_buffered_getc;
+	dev.tstc = serial_buffered_tstc;
+#else
+	dev.putc = serial_putc;
+	dev.puts = serial_puts;
+	dev.getc = serial_getc;
+	dev.tstc = serial_tstc;
+#endif
+
+	device_register (&dev);
+
+#ifdef CFG_DEVICE_NULLDEV
+	memset (&dev, 0, sizeof (dev));
+
+	strcpy (dev.name, "nulldev");
+	dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT | DEV_FLAGS_SYSTEM;
+	dev.putc = nulldev_putc;
+	dev.puts = nulldev_puts;
+	dev.getc = nulldev_input;
+	dev.tstc = nulldev_input;
+
+	device_register (&dev);
+#endif
+}
+
+/**************************************************************************
+ * DEVICES
+ **************************************************************************
+ */
+
+int device_register (device_t * dev)
+{
+	ListInsertItem (devlist, dev, LIST_END);
+	return 0;
+}
+
+/* deregister the device "devname".
+ * returns 0 if success, -1 if device is assigned and 1 if devname not found
+ */
+#ifdef	CFG_DEVICE_DEREGISTER
+int device_deregister(char *devname)
+{
+	int i,l,dev_index;
+	device_t *dev = NULL;
+	char temp_names[3][8];
+
+	dev_index=-1;
+	for (i=1; i<=ListNumItems(devlist); i++) {
+		dev = ListGetPtrToItem (devlist, i);
+		if(strcmp(dev->name,devname)==0) {
+			dev_index=i;
+			break;
+		}
+	}
+	if(dev_index<0) /* device not found */
+		return 0;
+	/* get stdio devices (ListRemoveItem changes the dev list) */
+	for (l=0 ; l< MAX_FILES; l++) {
+		if (stdio_devices[l] == dev) {
+			/* Device is assigned -> report error */
+			return -1;
+		}
+		memcpy (&temp_names[l][0],
+			stdio_devices[l]->name,
+			sizeof(stdio_devices[l]->name));
+	}
+	ListRemoveItem(devlist,NULL,dev_index);
+	/* reassign Device list */
+	for (i=1; i<=ListNumItems(devlist); i++) {
+		dev = ListGetPtrToItem (devlist, i);
+		for (l=0 ; l< MAX_FILES; l++) {
+			if(strcmp(dev->name,temp_names[l])==0) {
+				stdio_devices[l] = dev;
+			}
+		}
+	}
+	return 0;
+}
+#endif	/* CFG_DEVICE_DEREGISTER */
+
+int devices_init (void)
+{
+#ifndef CONFIG_ARM     /* already relocated for current ARM implementation */
+	ulong relocation_offset = gd->reloc_off;
+	int i;
+
+	/* relocate device name pointers */
+	for (i = 0; i < (sizeof (stdio_names) / sizeof (char *)); ++i) {
+		stdio_names[i] = (char *) (((ulong) stdio_names[i]) +
+						relocation_offset);
+	}
+#endif
+
+	/* Initialize the list */
+	devlist = ListCreate (sizeof (device_t));
+
+	if (devlist == NULL) {
+		eputs ("Cannot initialize the list of devices!\n");
+		return -1;
+	}
+#if defined(CONFIG_HARD_I2C) || defined(CONFIG_SOFT_I2C)
+	i2c_init (CFG_I2C_SPEED, CFG_I2C_SLAVE);
+#endif
+#ifdef CONFIG_LCD
+	drv_lcd_init ();
+#endif
+#if defined(CONFIG_VIDEO) || defined(CONFIG_CFB_CONSOLE)
+	drv_video_init ();
+#endif
+#ifdef CONFIG_KEYBOARD
+	drv_keyboard_init ();
+#endif
+#ifdef CONFIG_LOGBUFFER
+	drv_logbuff_init ();
+#endif
+	drv_system_init ();
+#ifdef CONFIG_SERIAL_MULTI
+	serial_devices_init ();
+#endif
+#ifdef CONFIG_USB_TTY
+	drv_usbtty_init ();
+#endif
+#ifdef CONFIG_NETCONSOLE
+	drv_nc_init ();
+#endif
+
+	return (0);
+}
+
+int devices_done (void)
+{
+	ListDispose (devlist);
+
+	return 0;
+}
--- /dev/null
+++ b/lib_bootstrap/display_options.c
@@ -0,0 +1,67 @@
+/*
+ * (C) Copyright 2000-2002
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+int display_options (void)
+{
+	extern char version_string[];
+
+#if defined(BUILD_TAG)
+	printf ("\n\n%s, Build: %s\n\n", version_string, BUILD_TAG);
+#else
+	printf ("\n\n%s\n\n", version_string);
+#endif
+	return 0;
+}
+
+/*
+ * print sizes as "xxx kB", "xxx.y kB", "xxx MB" or "xxx.y MB" as needed;
+ * allow for optional trailing string (like "\n")
+ */
+void print_size (ulong size, const char *s)
+{
+	ulong m, n;
+	ulong d = 1 << 20;		/* 1 MB */
+	char  c = 'M';
+
+	if (size < d) {			/* print in kB */
+		c = 'k';
+		d = 1 << 10;
+	}
+
+	n = size / d;
+
+	m = (10 * (size - (n * d)) + (d / 2) ) / d;
+
+	if (m >= 10) {
+		m -= 10;
+		n += 1;
+	}
+
+	printf ("%2ld", n);
+	if (m) {
+		printf (".%ld", m);
+	}
+	printf (" %cB%s", c, s);
+}
--- /dev/null
+++ b/lib_bootstrap/lists.c
@@ -0,0 +1,734 @@
+#include <common.h>
+#include <malloc.h>
+#include <lists.h>
+
+#define MAX(a,b) 	(((a)>(b)) ? (a) : (b))
+#define MIN(a,b) 	(((a)<(b)) ? (a) : (b))
+#define CAT4CHARS(a,b,c,d)	((a<<24) | (b<<16) | (c<<8) | d)
+
+/* increase list size by 10% every time it is full */
+#define kDefaultAllocationPercentIncrease	10
+
+/* always increase list size by 4 items when it is full */
+#define kDefaultAllocationminNumItemsIncrease	4
+
+/*
+ * how many items to expand the list by when it becomes full
+ * = current listSize (in items) + (hiword percent of list size) + loword
+ */
+#define NUMITEMSPERALLOC(list)	MAX(((*list)->listSize * \
+				    ((*list)->percentIncrease + 100)) / 100, \
+				    (*list)->minNumItemsIncrease )
+
+#define ITEMPTR(list,item)	&(((char *)&(*list)->itemList)[(*(list))->itemSize * (item)])
+
+#define LIST_SIGNATURE		CAT4CHARS('L', 'I', 'S', 'T');
+
+#define calloc(size,num)	malloc(size*num)
+
+/********************************************************************/
+
+Handle NewHandle (unsigned int numBytes)
+{
+	void *memPtr;
+	HandleRecord *hanPtr;
+
+	memPtr = calloc (numBytes, 1);
+	hanPtr = (HandleRecord *) calloc (sizeof (HandleRecord), 1);
+	if (hanPtr && (memPtr || numBytes == 0)) {
+		hanPtr->ptr = memPtr;
+		hanPtr->size = numBytes;
+		return (Handle) hanPtr;
+	} else {
+		free (memPtr);
+		free (hanPtr);
+		return NULL;
+	}
+}
+/********************************************************************/
+
+void DisposeHandle (Handle handle)
+{
+	if (handle) {
+		free (*handle);
+		free ((void *) handle);
+	}
+}
+/********************************************************************/
+
+unsigned int GetHandleSize (Handle handle)
+{
+	return ((HandleRecord *) handle)->size;
+}
+/********************************************************************/
+
+int SetHandleSize (Handle handle, unsigned int newSize)
+{
+	HandleRecord *hanRecPtr = (HandleRecord *) handle;
+	void *newPtr, *oldPtr;
+	unsigned int oldSize;
+
+
+	oldPtr = hanRecPtr->ptr;
+	oldSize = hanRecPtr->size;
+
+	if (oldSize == newSize)
+		return 1;
+
+	if (oldPtr == NULL) {
+		newPtr = malloc (newSize);
+	} else {
+		newPtr = realloc (oldPtr, newSize);
+	}
+	if (newPtr || (newSize == 0)) {
+		hanRecPtr->ptr = newPtr;
+		hanRecPtr->size = newSize;
+		if (newSize > oldSize)
+			memset ((char *) newPtr + oldSize, 0, newSize - oldSize);
+		return 1;
+	} else
+		return 0;
+}
+
+#ifdef	CFG_ALL_LIST_FUNCTIONS
+
+/*  Used to compare list elements by their raw data contents */
+static int ListMemBlockCmp (void *a, void *b, int size)
+{
+	return memcmp (a, b, size);
+}
+
+/***************************************************************************/
+
+/*
+ * Binary search numElements of size elementSize in array for a match
+ * to the. item. Return the index of the element that matches
+ * (0 - numElements - 1). If no match is found return the -i-1 where
+ * i is the index (0 - numElements) where the item should be placed.
+ * (*theCmp)(a,b) should return <0 if a<b, 0 if a==b, >0 if a>b.
+ *
+ * This function is like the C-Library function bsearch() except that
+ * this function returns the index where the item should be placed if
+ * it is not found.
+ */
+int BinSearch ( void *array, int numElements, int elementSize,
+		void *itemPtr, CompareFunction compareFunction)
+{
+	int low, high, mid, cmp;
+	void *arrayItemPtr;
+
+	for (low = 0, high = numElements - 1, mid = 0, cmp = -1; low <= high;) {
+		mid = (low + high) >> 1;
+
+		arrayItemPtr = (void *) (((char *) array) + (mid * elementSize));
+		cmp = compareFunction
+			? compareFunction (itemPtr, arrayItemPtr)
+			: ListMemBlockCmp (itemPtr, arrayItemPtr, elementSize);
+		if (cmp == 0) {
+			return mid;
+		} else if (cmp < 0) {
+			high = mid - 1;
+		} else {
+			low = mid + 1;
+		}
+	}
+	if (cmp > 0)
+		mid++;
+
+	return -mid - 1;
+}
+
+#endif	/* CFG_ALL_LIST_FUNCTIONS */
+
+/*******************************************************************************/
+
+/*
+ * If numNewItems == 0 then expand the list by the number of items
+ * indicated by its allocation policy.
+ * If numNewItems > 0 then expand the list by exactly the number of
+ * items indicated.
+ * If numNewItems < 0 then expand the list by the absolute value of
+ * numNewItems plus the number of items indicated by its allocation
+ * policy.
+ * Returns 1 for success, 0 if out of memory
+*/
+static int ExpandListSpace (list_t list, int numNewItems)
+{
+	if (numNewItems == 0) {
+		numNewItems = NUMITEMSPERALLOC (list);
+	} else if (numNewItems < 0) {
+		numNewItems = (-numNewItems) + NUMITEMSPERALLOC (list);
+	}
+
+	if (SetHandleSize ((Handle) list,
+			   sizeof (ListStruct) +
+			   ((*list)->listSize +
+			   numNewItems) * (*list)->itemSize)) {
+		(*list)->listSize += numNewItems;
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+/*******************************/
+
+#ifdef	CFG_ALL_LIST_FUNCTIONS
+
+/*
+ * This function reallocate the list, minus any currently unused
+ * portion of its allotted memory.
+ */
+void ListCompact (list_t list)
+{
+
+	if (!SetHandleSize ((Handle) list,
+			    sizeof (ListStruct) +
+			    (*list)->numItems * (*list)->itemSize)) {
+		return;
+	}
+
+	(*list)->listSize = (*list)->numItems;
+}
+
+#endif	/* CFG_ALL_LIST_FUNCTIONS */
+
+/*******************************/
+
+list_t ListCreate (int elementSize)
+{
+	list_t list;
+
+	list = (list_t) (NewHandle (sizeof (ListStruct)));  /* create empty list */
+	if (list) {
+		(*list)->signature = LIST_SIGNATURE;
+		(*list)->numItems = 0;
+		(*list)->listSize = 0;
+		(*list)->itemSize = elementSize;
+		(*list)->percentIncrease = kDefaultAllocationPercentIncrease;
+		(*list)->minNumItemsIncrease =
+				kDefaultAllocationminNumItemsIncrease;
+	}
+
+	return list;
+}
+
+/*******************************/
+
+void ListSetAllocationPolicy (list_t list, int minItemsPerAlloc,
+			      int percentIncreasePerAlloc)
+{
+	(*list)->percentIncrease = percentIncreasePerAlloc;
+	(*list)->minNumItemsIncrease = minItemsPerAlloc;
+}
+
+/*******************************/
+
+void ListDispose (list_t list)
+{
+	DisposeHandle ((Handle) list);
+}
+/*******************************/
+
+#ifdef	CFG_ALL_LIST_FUNCTIONS
+
+void ListDisposePtrList (list_t list)
+{
+	int index;
+	int numItems;
+
+	if (list) {
+		numItems = ListNumItems (list);
+
+		for (index = 1; index <= numItems; index++)
+			free (*(void **) ListGetPtrToItem (list, index));
+
+		ListDispose (list);
+	}
+}
+
+/*******************************/
+
+/*
+ * keeps memory, resets the number of items to 0
+ */
+void ListClear (list_t list)
+{
+	if (!list)
+		return;
+	(*list)->numItems = 0;
+}
+
+/*******************************/
+
+/*
+ * copy is only as large as necessary
+ */
+list_t ListCopy (list_t originalList)
+{
+	list_t tempList = NULL;
+	int numItems;
+
+	if (!originalList)
+		return NULL;
+
+	tempList = ListCreate ((*originalList)->itemSize);
+	if (tempList) {
+		numItems = ListNumItems (originalList);
+
+		if (!SetHandleSize ((Handle) tempList,
+				    sizeof (ListStruct) +
+				    numItems * (*tempList)->itemSize)) {
+			ListDispose (tempList);
+			return NULL;
+		}
+
+		(*tempList)->numItems = (*originalList)->numItems;
+		(*tempList)->listSize = (*originalList)->numItems;
+		(*tempList)->itemSize = (*originalList)->itemSize;
+		(*tempList)->percentIncrease = (*originalList)->percentIncrease;
+		(*tempList)->minNumItemsIncrease =
+				(*originalList)->minNumItemsIncrease;
+
+		memcpy (ITEMPTR (tempList, 0), ITEMPTR (originalList, 0),
+				numItems * (*tempList)->itemSize);
+	}
+
+	return tempList;
+}
+
+/********************************/
+
+/*
+ * list1 = list1 + list2
+ */
+int ListAppend (list_t list1, list_t list2)
+{
+	int numItemsL1, numItemsL2;
+
+	if (!list2)
+		return 1;
+
+	if (!list1)
+		return 0;
+	if ((*list1)->itemSize != (*list2)->itemSize)
+		return 0;
+
+	numItemsL1 = ListNumItems (list1);
+	numItemsL2 = ListNumItems (list2);
+
+	if (numItemsL2 == 0)
+		return 1;
+
+	if (!SetHandleSize ((Handle) list1,
+			    sizeof (ListStruct) + (numItemsL1 + numItemsL2) *
+					(*list1)->itemSize)) {
+		return 0;
+	}
+
+	(*list1)->numItems = numItemsL1 + numItemsL2;
+	(*list1)->listSize = numItemsL1 + numItemsL2;
+
+	memmove (ITEMPTR (list1, numItemsL1),
+		 ITEMPTR (list2, 0),
+		 numItemsL2 * (*list2)->itemSize);
+
+	return 1;
+}
+
+#endif	/* CFG_ALL_LIST_FUNCTIONS */
+
+/*******************************/
+
+/*
+ * returns 1 if the item is inserted, returns 0 if out of memory or
+ * bad arguments were passed.
+ */
+int ListInsertItem (list_t list, void *ptrToItem, int itemPosition)
+{
+	return ListInsertItems (list, ptrToItem, itemPosition, 1);
+}
+
+/*******************************/
+
+int ListInsertItems (list_t list, void *ptrToItems, int firstItemPosition,
+		     int numItemsToInsert)
+{
+	int numItems = (*list)->numItems;
+
+	if (firstItemPosition == numItems + 1)
+		firstItemPosition = LIST_END;
+	else if (firstItemPosition > numItems)
+		return 0;
+
+	if ((*list)->numItems >= (*list)->listSize) {
+		if (!ExpandListSpace (list, -numItemsToInsert))
+			return 0;
+	}
+
+	if (firstItemPosition == LIST_START) {
+		if (numItems == 0) {
+			/* special case for empty list */
+			firstItemPosition = LIST_END;
+		} else {
+			firstItemPosition = 1;
+		}
+	}
+
+	if (firstItemPosition == LIST_END) {	/* add at the end of the list */
+		if (ptrToItems)
+			memcpy (ITEMPTR (list, numItems), ptrToItems,
+					(*list)->itemSize * numItemsToInsert);
+		else
+			memset (ITEMPTR (list, numItems), 0,
+					(*list)->itemSize * numItemsToInsert);
+
+		(*list)->numItems += numItemsToInsert;
+	} else {					/* move part of list up to make room for new item */
+		memmove (ITEMPTR (list, firstItemPosition - 1 + numItemsToInsert),
+			 ITEMPTR (list, firstItemPosition - 1),
+			 (numItems + 1 - firstItemPosition) * (*list)->itemSize);
+
+		if (ptrToItems)
+			memmove (ITEMPTR (list, firstItemPosition - 1), ptrToItems,
+					 (*list)->itemSize * numItemsToInsert);
+		else
+			memset (ITEMPTR (list, firstItemPosition - 1), 0,
+					(*list)->itemSize * numItemsToInsert);
+
+		(*list)->numItems += numItemsToInsert;
+	}
+
+	return 1;
+}
+
+#ifdef CFG_ALL_LIST_FUNCTIONS
+
+/*******************************/
+
+int ListEqual (list_t list1, list_t list2)
+{
+	if (list1 == list2)
+		return 1;
+
+	if (list1 == NULL || list2 == NULL)
+		return 0;
+
+	if ((*list1)->itemSize == (*list1)->itemSize) {
+	    if ((*list1)->numItems == (*list2)->numItems) {
+		return (memcmp (ITEMPTR (list1, 0), ITEMPTR (list2, 0),
+				(*list1)->itemSize * (*list1)->numItems) == 0);
+	    }
+	}
+
+	return 0;
+}
+
+/*******************************/
+
+/*
+ * The item pointed to by ptrToItem is copied over the current item
+ * at itemPosition
+ */
+void ListReplaceItem (list_t list, void *ptrToItem, int itemPosition)
+{
+	ListReplaceItems (list, ptrToItem, itemPosition, 1);
+}
+
+/*******************************/
+
+/*
+ * The item pointed to by ptrToItems is copied over the current item
+ * at itemPosition
+ */
+void ListReplaceItems ( list_t list, void *ptrToItems,
+			int firstItemPosition, int numItemsToReplace)
+{
+
+	if (firstItemPosition == LIST_END)
+		firstItemPosition = (*list)->numItems;
+	else if (firstItemPosition == LIST_START)
+		firstItemPosition = 1;
+
+	memmove (ITEMPTR (list, firstItemPosition - 1), ptrToItems,
+			 (*list)->itemSize * numItemsToReplace);
+}
+
+/*******************************/
+
+void ListGetItem (list_t list, void *itemDestination, int itemPosition)
+{
+	ListGetItems (list, itemDestination, itemPosition, 1);
+}
+
+#endif	/* CFG_ALL_LIST_FUNCTIONS */
+
+/*******************************/
+
+#if defined(CFG_ALL_LIST_FUNCTIONS) || defined(CFG_DEVICE_DEREGISTER)
+
+void ListRemoveItem (list_t list, void *itemDestination, int itemPosition)
+{
+	ListRemoveItems (list, itemDestination, itemPosition, 1);
+}
+
+/*******************************/
+
+void ListRemoveItems (list_t list, void *itemsDestination,
+		      int firstItemPosition, int numItemsToRemove)
+{
+	int firstItemAfterChunk, numToMove;
+
+	if (firstItemPosition == LIST_START)
+		firstItemPosition = 1;
+	else if (firstItemPosition == LIST_END)
+		firstItemPosition = (*list)->numItems;
+
+	if (itemsDestination != NULL)
+		memcpy (itemsDestination, ITEMPTR (list, firstItemPosition - 1),
+				(*list)->itemSize * numItemsToRemove);
+
+	firstItemAfterChunk = firstItemPosition + numItemsToRemove;
+	numToMove = (*list)->numItems - (firstItemAfterChunk - 1);
+
+	if (numToMove > 0) {
+		/*
+		 * move part of list down to cover hole left by removed item
+		 */
+		memmove (ITEMPTR (list, firstItemPosition - 1),
+				 ITEMPTR (list, firstItemAfterChunk - 1),
+				 (*list)->itemSize * numToMove);
+	}
+
+	(*list)->numItems -= numItemsToRemove;
+}
+#endif	/* CFG_ALL_LIST_FUNCTIONS || CFG_DEVICE_DEREGISTER */
+
+/*******************************/
+
+void ListGetItems (list_t list, void *itemsDestination,
+		   int firstItemPosition, int numItemsToGet)
+{
+
+	if (firstItemPosition == LIST_START)
+		firstItemPosition = 1;
+	else if (firstItemPosition == LIST_END)
+		firstItemPosition = (*list)->numItems;
+
+	memcpy (itemsDestination,
+		ITEMPTR (list, firstItemPosition - 1),
+		(*list)->itemSize * numItemsToGet);
+}
+
+/*******************************/
+
+/*
+ * Returns a pointer to the item at itemPosition. returns null if an
+ * errors occurred.
+ */
+void *ListGetPtrToItem (list_t list, int itemPosition)
+{
+	if (itemPosition == LIST_START)
+		itemPosition = 1;
+	else if (itemPosition == LIST_END)
+		itemPosition = (*list)->numItems;
+
+	return ITEMPTR (list, itemPosition - 1);
+}
+
+/*******************************/
+
+/*
+ * returns a pointer the lists data (abstraction violation for
+ * optimization)
+ */
+void *ListGetDataPtr (list_t list)
+{
+	return &((*list)->itemList[0]);
+}
+
+/********************************/
+
+#ifdef	CFG_ALL_LIST_FUNCTIONS
+
+int ListApplyToEach (list_t list, int ascending,
+		     ListApplicationFunc funcToApply,
+		     void *callbackData)
+{
+	int result = 0, index;
+
+	if (!list || !funcToApply)
+		goto Error;
+
+	if (ascending) {
+		for (index = 1; index <= ListNumItems (list); index++) {
+			result = funcToApply (index,
+					      ListGetPtrToItem (list, index),
+					      callbackData);
+			if (result < 0)
+				goto Error;
+		}
+	} else {
+		for (index = ListNumItems (list);
+		     index > 0 && index <= ListNumItems (list);
+		     index--) {
+			result = funcToApply (index,
+					      ListGetPtrToItem (list, index),
+					      callbackData);
+			if (result < 0)
+				goto Error;
+		}
+	}
+
+Error:
+	return result;
+}
+
+#endif /* CFG_ALL_LIST_FUNCTIONS */
+
+/********************************/
+
+int ListGetItemSize (list_t list)
+{
+	return (*list)->itemSize;
+}
+
+/********************************/
+
+int ListNumItems (list_t list)
+{
+	return (*list)->numItems;
+}
+
+/*******************************/
+
+#ifdef	CFG_ALL_LIST_FUNCTIONS
+
+void ListRemoveDuplicates (list_t list, CompareFunction compareFunction)
+{
+	int numItems, index, startIndexForFind, duplicatesIndex;
+
+	numItems = ListNumItems (list);
+
+	for (index = 1; index < numItems; index++) {
+		startIndexForFind = index + 1;
+		while (startIndexForFind <= numItems) {
+			duplicatesIndex =
+				ListFindItem (list,
+					      ListGetPtrToItem (list, index),
+					      startIndexForFind,
+					      compareFunction);
+			if (duplicatesIndex > 0) {
+				ListRemoveItem (list, NULL, duplicatesIndex);
+				numItems--;
+				startIndexForFind = duplicatesIndex;
+			} else {
+				break;
+			}
+		}
+	}
+}
+
+/*******************************/
+
+
+/*******************************/
+
+int ListFindItem (list_t list, void *ptrToItem, int startingPosition,
+		  CompareFunction compareFunction)
+{
+	int numItems, size, index, cmp;
+	void *listItemPtr;
+
+	if ((numItems = (*list)->numItems) == 0)
+		return 0;
+
+	size = (*list)->itemSize;
+
+	if (startingPosition == LIST_START)
+		startingPosition = 1;
+	else if (startingPosition == LIST_END)
+		startingPosition = numItems;
+
+	for (index = startingPosition; index <= numItems; index++) {
+		listItemPtr = ITEMPTR (list, index - 1);
+		cmp = compareFunction
+			? compareFunction (ptrToItem, listItemPtr)
+			: ListMemBlockCmp (ptrToItem, listItemPtr, size);
+		if (cmp == 0)
+			return index;
+	}
+
+	return 0;
+}
+
+/*******************************/
+
+int ShortCompare (void *a, void *b)
+{
+	if (*(short *) a < *(short *) b)
+		return -1;
+	if (*(short *) a > *(short *) b)
+		return 1;
+	return 0;
+}
+
+/*******************************/
+
+int IntCompare (void *a, void *b)
+{
+	if (*(int *) a < *(int *) b)
+		return -1;
+	if (*(int *) a > *(int *) b)
+		return 1;
+	return 0;
+}
+
+/*******************************/
+
+int CStringCompare (void *a, void *b)
+{
+	return strcmp (*(char **) a, *(char **) b);
+}
+
+/*******************************/
+
+
+int ListBinSearch (list_t list, void *ptrToItem,
+		   CompareFunction compareFunction)
+{
+	int index;
+
+	index = BinSearch (ITEMPTR (list, 0),
+			   (int) (*list)->numItems,
+			   (int) (*list)->itemSize, ptrToItem,
+			   compareFunction);
+
+	if (index >= 0)
+		index++;			/* lists start from 1 */
+	else
+		index = 0;			/* item not found */
+
+	return index;
+}
+
+/**************************************************************************/
+
+/*
+ * Reserves memory for numItems in the list. If it succeeds then
+ * numItems items can be inserted without possibility of an out of
+ * memory error (useful to simplify error recovery in complex
+ * functions). Returns 1 if success, 0 if out of memory.
+ */
+int ListPreAllocate (list_t list, int numItems)
+{
+	if ((*list)->listSize - (*list)->numItems < numItems) {
+		return ExpandListSpace (list,
+					numItems - ((*list)->listSize -
+						(*list)->numItems));
+	} else {
+		return 1;	/* enough items are already pre-allocated */
+	}
+}
+
+#endif /* CFG_ALL_LIST_FUNCTIONS */
--- /dev/null
+++ b/lib_bootstrap/string.c
@@ -0,0 +1,578 @@
+/*
+ *  linux/lib/string.c
+ *
+ *  Copyright (C) 1991, 1992  Linus Torvalds
+ */
+
+/*
+ * stupid library routines.. The optimized versions should generally be found
+ * as inline code in <asm-xx/string.h>
+ *
+ * These are buggy as well..
+ *
+ * * Fri Jun 25 1999, Ingo Oeser <ioe@informatik.tu-chemnitz.de>
+ * -  Added strsep() which will replace strtok() soon (because strsep() is
+ *    reentrant and should be faster). Use only strsep() in new code, please.
+ */
+
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+#include <malloc.h>
+
+
+#if 0 /* not used - was: #ifndef __HAVE_ARCH_STRNICMP */
+/**
+ * strnicmp - Case insensitive, length-limited string comparison
+ * @s1: One string
+ * @s2: The other string
+ * @len: the maximum number of characters to compare
+ */
+int strnicmp(const char *s1, const char *s2, size_t len)
+{
+	/* Yes, Virginia, it had better be unsigned */
+	unsigned char c1, c2;
+
+	c1 = 0;	c2 = 0;
+	if (len) {
+		do {
+			c1 = *s1; c2 = *s2;
+			s1++; s2++;
+			if (!c1)
+				break;
+			if (!c2)
+				break;
+			if (c1 == c2)
+				continue;
+			c1 = tolower(c1);
+			c2 = tolower(c2);
+			if (c1 != c2)
+				break;
+		} while (--len);
+	}
+	return (int)c1 - (int)c2;
+}
+#endif
+
+char * ___strtok;
+
+#ifndef __HAVE_ARCH_STRCPY
+/**
+ * strcpy - Copy a %NUL terminated string
+ * @dest: Where to copy the string to
+ * @src: Where to copy the string from
+ */
+char * strcpy(char * dest,const char *src)
+{
+	char *tmp = dest;
+
+	while ((*dest++ = *src++) != '\0')
+		/* nothing */;
+	return tmp;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRNCPY
+/**
+ * strncpy - Copy a length-limited, %NUL-terminated string
+ * @dest: Where to copy the string to
+ * @src: Where to copy the string from
+ * @count: The maximum number of bytes to copy
+ *
+ * Note that unlike userspace strncpy, this does not %NUL-pad the buffer.
+ * However, the result is not %NUL-terminated if the source exceeds
+ * @count bytes.
+ */
+char * strncpy(char * dest,const char *src,size_t count)
+{
+	char *tmp = dest;
+
+	while (count-- && (*dest++ = *src++) != '\0')
+		/* nothing */;
+
+	return tmp;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRCAT
+/**
+ * strcat - Append one %NUL-terminated string to another
+ * @dest: The string to be appended to
+ * @src: The string to append to it
+ */
+char * strcat(char * dest, const char * src)
+{
+	char *tmp = dest;
+
+	while (*dest)
+		dest++;
+	while ((*dest++ = *src++) != '\0')
+		;
+
+	return tmp;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRNCAT
+/**
+ * strncat - Append a length-limited, %NUL-terminated string to another
+ * @dest: The string to be appended to
+ * @src: The string to append to it
+ * @count: The maximum numbers of bytes to copy
+ *
+ * Note that in contrast to strncpy, strncat ensures the result is
+ * terminated.
+ */
+char * strncat(char *dest, const char *src, size_t count)
+{
+	char *tmp = dest;
+
+	if (count) {
+		while (*dest)
+			dest++;
+		while ((*dest++ = *src++)) {
+			if (--count == 0) {
+				*dest = '\0';
+				break;
+			}
+		}
+	}
+
+	return tmp;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRCMP
+/**
+ * strcmp - Compare two strings
+ * @cs: One string
+ * @ct: Another string
+ */
+int strcmp(const char * cs,const char * ct)
+{
+	register signed char __res;
+
+	while (1) {
+		if ((__res = *cs - *ct++) != 0 || !*cs++)
+			break;
+	}
+
+	return __res;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRNCMP
+/**
+ * strncmp - Compare two length-limited strings
+ * @cs: One string
+ * @ct: Another string
+ * @count: The maximum number of bytes to compare
+ */
+int strncmp(const char * cs,const char * ct,size_t count)
+{
+	register signed char __res = 0;
+
+	while (count) {
+		if ((__res = *cs - *ct++) != 0 || !*cs++)
+			break;
+		count--;
+	}
+
+	return __res;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRCHR
+/**
+ * strchr - Find the first occurrence of a character in a string
+ * @s: The string to be searched
+ * @c: The character to search for
+ */
+char * strchr(const char * s, int c)
+{
+	for(; *s != (char) c; ++s)
+		if (*s == '\0')
+			return NULL;
+	return (char *) s;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRRCHR
+/**
+ * strrchr - Find the last occurrence of a character in a string
+ * @s: The string to be searched
+ * @c: The character to search for
+ */
+char * strrchr(const char * s, int c)
+{
+       const char *p = s + strlen(s);
+       do {
+	   if (*p == (char)c)
+	       return (char *)p;
+       } while (--p >= s);
+       return NULL;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRLEN
+/**
+ * strlen - Find the length of a string
+ * @s: The string to be sized
+ */
+size_t strlen(const char * s)
+{
+	const char *sc;
+
+	for (sc = s; *sc != '\0'; ++sc)
+		/* nothing */;
+	return sc - s;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRNLEN
+/**
+ * strnlen - Find the length of a length-limited string
+ * @s: The string to be sized
+ * @count: The maximum number of bytes to search
+ */
+size_t strnlen(const char * s, size_t count)
+{
+	const char *sc;
+
+	for (sc = s; count-- && *sc != '\0'; ++sc)
+		/* nothing */;
+	return sc - s;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRDUP
+char * strdup(const char *s)
+{
+	char *new;
+
+	if ((s == NULL)	||
+	    ((new = malloc (strlen(s) + 1)) == NULL) ) {
+		return NULL;
+	}
+
+	strcpy (new, s);
+	return new;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRSPN
+/**
+ * strspn - Calculate the length of the initial substring of @s which only
+ * 	contain letters in @accept
+ * @s: The string to be searched
+ * @accept: The string to search for
+ */
+size_t strspn(const char *s, const char *accept)
+{
+	const char *p;
+	const char *a;
+	size_t count = 0;
+
+	for (p = s; *p != '\0'; ++p) {
+		for (a = accept; *a != '\0'; ++a) {
+			if (*p == *a)
+				break;
+		}
+		if (*a == '\0')
+			return count;
+		++count;
+	}
+
+	return count;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRPBRK
+/**
+ * strpbrk - Find the first occurrence of a set of characters
+ * @cs: The string to be searched
+ * @ct: The characters to search for
+ */
+char * strpbrk(const char * cs,const char * ct)
+{
+	const char *sc1,*sc2;
+
+	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
+		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
+			if (*sc1 == *sc2)
+				return (char *) sc1;
+		}
+	}
+	return NULL;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRTOK
+/**
+ * strtok - Split a string into tokens
+ * @s: The string to be searched
+ * @ct: The characters to search for
+ *
+ * WARNING: strtok is deprecated, use strsep instead.
+ */
+char * strtok(char * s,const char * ct)
+{
+	char *sbegin, *send;
+
+	sbegin  = s ? s : ___strtok;
+	if (!sbegin) {
+		return NULL;
+	}
+	sbegin += strspn(sbegin,ct);
+	if (*sbegin == '\0') {
+		___strtok = NULL;
+		return( NULL );
+	}
+	send = strpbrk( sbegin, ct);
+	if (send && *send != '\0')
+		*send++ = '\0';
+	___strtok = send;
+	return (sbegin);
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRSEP
+/**
+ * strsep - Split a string into tokens
+ * @s: The string to be searched
+ * @ct: The characters to search for
+ *
+ * strsep() updates @s to point after the token, ready for the next call.
+ *
+ * It returns empty tokens, too, behaving exactly like the libc function
+ * of that name. In fact, it was stolen from glibc2 and de-fancy-fied.
+ * Same semantics, slimmer shape. ;)
+ */
+char * strsep(char **s, const char *ct)
+{
+	char *sbegin = *s, *end;
+
+	if (sbegin == NULL)
+		return NULL;
+
+	end = strpbrk(sbegin, ct);
+	if (end)
+		*end++ = '\0';
+	*s = end;
+
+	return sbegin;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRSWAB
+/**
+ * strswab - swap adjacent even and odd bytes in %NUL-terminated string
+ * s: address of the string
+ *
+ * returns the address of the swapped string or NULL on error. If
+ * string length is odd, last byte is untouched.
+ */
+char *strswab(const char *s)
+{
+	char *p, *q;
+
+	if ((NULL == s) || ('\0' == *s)) {
+		return (NULL);
+	}
+
+	for (p=(char *)s, q=p+1; (*p != '\0') && (*q != '\0'); p+=2, q+=2) {
+		char  tmp;
+
+		tmp = *p;
+		*p  = *q;
+		*q  = tmp;
+	}
+
+	return (char *) s;
+}
+#endif
+
+#ifndef __HAVE_ARCH_MEMSET
+/**
+ * memset - Fill a region of memory with the given value
+ * @s: Pointer to the start of the area.
+ * @c: The byte to fill the area with
+ * @count: The size of the area.
+ *
+ * Do not use memset() to access IO space, use memset_io() instead.
+ */
+void * memset(void * s,int c,size_t count)
+{
+	char *xs = (char *) s;
+
+	while (count--)
+		*xs++ = c;
+
+	return s;
+}
+#endif
+
+#ifndef __HAVE_ARCH_BCOPY
+/**
+ * bcopy - Copy one area of memory to another
+ * @src: Where to copy from
+ * @dest: Where to copy to
+ * @count: The size of the area.
+ *
+ * Note that this is the same as memcpy(), with the arguments reversed.
+ * memcpy() is the standard, bcopy() is a legacy BSD function.
+ *
+ * You should not use this function to access IO space, use memcpy_toio()
+ * or memcpy_fromio() instead.
+ */
+char * bcopy(const char * src, char * dest, int count)
+{
+	char *tmp = dest;
+
+	while (count--)
+		*tmp++ = *src++;
+
+	return dest;
+}
+#endif
+
+#ifndef __HAVE_ARCH_MEMCPY
+/**
+ * memcpy - Copy one area of memory to another
+ * @dest: Where to copy to
+ * @src: Where to copy from
+ * @count: The size of the area.
+ *
+ * You should not use this function to access IO space, use memcpy_toio()
+ * or memcpy_fromio() instead.
+ */
+void * memcpy(void * dest,const void *src,size_t count)
+{
+	char *tmp = (char *) dest, *s = (char *) src;
+
+	while (count--)
+		*tmp++ = *s++;
+
+	return dest;
+}
+#endif
+
+#ifndef __HAVE_ARCH_MEMMOVE
+/**
+ * memmove - Copy one area of memory to another
+ * @dest: Where to copy to
+ * @src: Where to copy from
+ * @count: The size of the area.
+ *
+ * Unlike memcpy(), memmove() copes with overlapping areas.
+ */
+void * memmove(void * dest,const void *src,size_t count)
+{
+	char *tmp, *s;
+
+	if (dest <= src) {
+		tmp = (char *) dest;
+		s = (char *) src;
+		while (count--)
+			*tmp++ = *s++;
+		}
+	else {
+		tmp = (char *) dest + count;
+		s = (char *) src + count;
+		while (count--)
+			*--tmp = *--s;
+		}
+
+	return dest;
+}
+#endif
+
+#ifndef __HAVE_ARCH_MEMCMP
+/**
+ * memcmp - Compare two areas of memory
+ * @cs: One area of memory
+ * @ct: Another area of memory
+ * @count: The size of the area.
+ */
+int memcmp(const void * cs,const void * ct,size_t count)
+{
+	const unsigned char *su1, *su2;
+	int res = 0;
+
+	for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
+		if ((res = *su1 - *su2) != 0)
+			break;
+	return res;
+}
+#endif
+
+#ifndef __HAVE_ARCH_MEMSCAN
+/**
+ * memscan - Find a character in an area of memory.
+ * @addr: The memory area
+ * @c: The byte to search for
+ * @size: The size of the area.
+ *
+ * returns the address of the first occurrence of @c, or 1 byte past
+ * the area if @c is not found
+ */
+void * memscan(void * addr, int c, size_t size)
+{
+	unsigned char * p = (unsigned char *) addr;
+
+	while (size) {
+		if (*p == c)
+			return (void *) p;
+		p++;
+		size--;
+	}
+	return (void *) p;
+}
+#endif
+
+#ifndef __HAVE_ARCH_STRSTR
+/**
+ * strstr - Find the first substring in a %NUL terminated string
+ * @s1: The string to be searched
+ * @s2: The string to search for
+ */
+char * strstr(const char * s1,const char * s2)
+{
+	int l1, l2;
+
+	l2 = strlen(s2);
+	if (!l2)
+		return (char *) s1;
+	l1 = strlen(s1);
+	while (l1 >= l2) {
+		l1--;
+		if (!memcmp(s1,s2,l2))
+			return (char *) s1;
+		s1++;
+	}
+	return NULL;
+}
+#endif
+
+#ifndef __HAVE_ARCH_MEMCHR
+/**
+ * memchr - Find a character in an area of memory.
+ * @s: The memory area
+ * @c: The byte to search for
+ * @n: The size of the area.
+ *
+ * returns the address of the first occurrence of @c, or %NULL
+ * if @c is not found
+ */
+void *memchr(const void *s, int c, size_t n)
+{
+	const unsigned char *p = s;
+	while (n-- != 0) {
+		if ((unsigned char)c == *p++) {
+			return (void *)(p-1);
+		}
+	}
+	return NULL;
+}
+
+#endif
--- /dev/null
+++ b/lib_bootstrap/time.c
@@ -0,0 +1,99 @@
+/*
+ * (C) Copyright 2003
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+
+static inline void mips_compare_set(u32 v)
+{
+	asm volatile ("mtc0 %0, $11" : : "r" (v));
+}
+
+static inline void mips_count_set(u32 v)
+{
+	asm volatile ("mtc0 %0, $9" : : "r" (v));
+}
+
+
+static inline u32 mips_count_get(void)
+{
+	u32 count;
+
+	asm volatile ("mfc0 %0, $9" : "=r" (count) :);
+	return count;
+}
+
+/*
+ * timer without interrupts
+ */
+
+int timer_init(void)
+{
+	mips_compare_set(0);
+	mips_count_set(0);
+
+	return 0;
+}
+
+void reset_timer(void)
+{
+	mips_count_set(0);
+}
+
+ulong get_timer(ulong base)
+{
+	return mips_count_get() - base;
+}
+
+void set_timer(ulong t)
+{
+	mips_count_set(t);
+}
+
+void udelay (unsigned long usec)
+{
+	ulong tmo;
+	ulong start = get_timer(0);
+
+	tmo = usec * (CFG_HZ / 1000000);
+	while ((ulong)((mips_count_get() - start)) < tmo)
+		/*NOP*/;
+}
+
+/*
+ * This function is derived from PowerPC code (read timebase as long long).
+ * On MIPS it just returns the timer value.
+ */
+unsigned long long get_ticks(void)
+{
+	return mips_count_get();
+}
+
+/*
+ * This function is derived from PowerPC code (timebase clock frequency).
+ * On MIPS it returns the number of timer ticks per second.
+ */
+ulong get_tbclk(void)
+{
+	return CFG_HZ;
+}
--- /dev/null
+++ b/lib_bootstrap/vsprintf.c
@@ -0,0 +1,385 @@
+/*
+ *  linux/lib/vsprintf.c
+ *
+ *  Copyright (C) 1991, 1992  Linus Torvalds
+ */
+
+/* vsprintf.c -- Lars Wirzenius & Linus Torvalds. */
+/*
+ * Wirzenius wrote this portably, Torvalds fucked it up :-)
+ */
+
+#include <stdarg.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/ctype.h>
+
+#include <common.h>
+#if !defined (CONFIG_PANIC_HANG)
+#include <command.h>
+/*cmd_boot.c*/
+extern int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
+#endif
+
+unsigned long simple_strtoul(const char *cp,char **endp,unsigned int base)
+{
+	unsigned long result = 0,value;
+
+	if (*cp == '0') {
+		cp++;
+		if ((*cp == 'x') && isxdigit(cp[1])) {
+			base = 16;
+			cp++;
+		}
+		if (!base) {
+			base = 8;
+		}
+	}
+	if (!base) {
+		base = 10;
+	}
+	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
+	    ? toupper(*cp) : *cp)-'A'+10) < base) {
+		result = result*base + value;
+		cp++;
+	}
+	if (endp)
+		*endp = (char *)cp;
+	return result;
+}
+
+long simple_strtol(const char *cp,char **endp,unsigned int base)
+{
+	if(*cp=='-')
+		return -simple_strtoul(cp+1,endp,base);
+	return simple_strtoul(cp,endp,base);
+}
+
+#ifdef CFG_64BIT_STRTOUL
+unsigned long long simple_strtoull (const char *cp, char **endp, unsigned int base)
+{
+	unsigned long long result = 0, value;
+
+	if (*cp == '0') {
+		cp++;
+		if ((*cp == 'x') && isxdigit (cp[1])) {
+			base = 16;
+			cp++;
+		}
+		if (!base) {
+			base = 8;
+		}
+	}
+	if (!base) {
+		base = 10;
+	}
+	while (isxdigit (*cp) && (value = isdigit (*cp)
+				? *cp - '0'
+				: (islower (*cp) ? toupper (*cp) : *cp) - 'A' + 10) < base) {
+		result = result * base + value;
+		cp++;
+	}
+	if (endp)
+		*endp = (char *) cp;
+	return result;
+}
+#endif /* CFG_64BIT_STRTOUL */
+
+/* we use this so that we can do without the ctype library */
+#define is_digit(c)	((c) >= '0' && (c) <= '9')
+
+static int skip_atoi(const char **s)
+{
+	int i=0;
+
+	while (is_digit(**s))
+		i = i*10 + *((*s)++) - '0';
+	return i;
+}
+
+#define ZEROPAD	1		/* pad with zero */
+#define SIGN	2		/* unsigned/signed long */
+#define PLUS	4		/* show plus */
+#define SPACE	8		/* space if plus */
+#define LEFT	16		/* left justified */
+#define SPECIAL	32		/* 0x */
+#define LARGE	64		/* use 'ABCDEF' instead of 'abcdef' */
+
+#define do_div(n,base) ({ \
+	int __res; \
+	__res = ((unsigned long) n) % (unsigned) base; \
+	n = ((unsigned long) n) / (unsigned) base; \
+	__res; \
+})
+
+#ifdef CFG_64BIT_VSPRINTF
+static char * number(char * str, long long num, int base, int size, int precision ,int type)
+#else
+static char * number(char * str, long num, int base, int size, int precision ,int type)
+#endif
+{
+	char c,sign,tmp[66];
+	const char *digits="0123456789abcdefghijklmnopqrstuvwxyz";
+	int i;
+
+	if (type & LARGE)
+		digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
+	if (type & LEFT)
+		type &= ~ZEROPAD;
+	if (base < 2 || base > 36)
+		return 0;
+	c = (type & ZEROPAD) ? '0' : ' ';
+	sign = 0;
+	if (type & SIGN) {
+		if (num < 0) {
+			sign = '-';
+			num = -num;
+			size--;
+		} else if (type & PLUS) {
+			sign = '+';
+			size--;
+		} else if (type & SPACE) {
+			sign = ' ';
+			size--;
+		}
+	}
+	if (type & SPECIAL) {
+		if (base == 16)
+			size -= 2;
+		else if (base == 8)
+			size--;
+	}
+	i = 0;
+	if (num == 0)
+		tmp[i++]='0';
+	else while (num != 0)
+		tmp[i++] = digits[do_div(num,base)];
+	if (i > precision)
+		precision = i;
+	size -= precision;
+	if (!(type&(ZEROPAD+LEFT)))
+		while(size-->0)
+			*str++ = ' ';
+	if (sign)
+		*str++ = sign;
+	if (type & SPECIAL) {
+		if (base==8)
+			*str++ = '0';
+		else if (base==16) {
+			*str++ = '0';
+			*str++ = digits[33];
+		}
+	}
+	if (!(type & LEFT))
+		while (size-- > 0)
+			*str++ = c;
+	while (i < precision--)
+		*str++ = '0';
+	while (i-- > 0)
+		*str++ = tmp[i];
+	while (size-- > 0)
+		*str++ = ' ';
+	return str;
+}
+
+/* Forward decl. needed for IP address printing stuff... */
+int sprintf(char * buf, const char *fmt, ...);
+
+int vsprintf(char *buf, const char *fmt, va_list args)
+{
+	int len;
+#ifdef CFG_64BIT_VSPRINTF
+	unsigned long long num;
+#else
+	unsigned long num;
+#endif
+	int i, base;
+	char * str;
+	const char *s;
+
+	int flags;		/* flags to number() */
+
+	int field_width;	/* width of output field */
+	int precision;		/* min. # of digits for integers; max
+				   number of chars for from string */
+	int qualifier;		/* 'h', 'l', or 'q' for integer fields */
+
+	for (str=buf ; *fmt ; ++fmt) {
+		if (*fmt != '%') {
+			*str++ = *fmt;
+			continue;
+		}
+
+		/* process flags */
+		flags = 0;
+		repeat:
+			++fmt;		/* this also skips first '%' */
+			switch (*fmt) {
+				case '-': flags |= LEFT; goto repeat;
+				case '+': flags |= PLUS; goto repeat;
+				case ' ': flags |= SPACE; goto repeat;
+				case '#': flags |= SPECIAL; goto repeat;
+				case '0': flags |= ZEROPAD; goto repeat;
+				}
+
+		/* get field width */
+		field_width = -1;
+		if (is_digit(*fmt))
+			field_width = skip_atoi(&fmt);
+		else if (*fmt == '*') {
+			++fmt;
+			/* it's the next argument */
+			field_width = va_arg(args, int);
+			if (field_width < 0) {
+				field_width = -field_width;
+				flags |= LEFT;
+			}
+		}
+
+		/* get the precision */
+		precision = -1;
+		if (*fmt == '.') {
+			++fmt;
+			if (is_digit(*fmt))
+				precision = skip_atoi(&fmt);
+			else if (*fmt == '*') {
+				++fmt;
+				/* it's the next argument */
+				precision = va_arg(args, int);
+			}
+			if (precision < 0)
+				precision = 0;
+		}
+
+		/* get the conversion qualifier */
+		qualifier = -1;
+		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'q') {
+			qualifier = *fmt;
+			++fmt;
+		}
+
+		/* default base */
+		base = 10;
+
+		switch (*fmt) {
+		case 'c':
+			if (!(flags & LEFT))
+				while (--field_width > 0)
+					*str++ = ' ';
+			*str++ = (unsigned char) va_arg(args, int);
+			while (--field_width > 0)
+				*str++ = ' ';
+			continue;
+
+		case 's':
+			s = va_arg(args, char *);
+			if (!s)
+				s = "<NULL>";
+
+			len = strnlen(s, precision);
+
+			if (!(flags & LEFT))
+				while (len < field_width--)
+					*str++ = ' ';
+			for (i = 0; i < len; ++i)
+				*str++ = *s++;
+			while (len < field_width--)
+				*str++ = ' ';
+			continue;
+
+		case 'p':
+			if (field_width == -1) {
+				field_width = 2*sizeof(void *);
+				flags |= ZEROPAD;
+			}
+			str = number(str,
+				(unsigned long) va_arg(args, void *), 16,
+				field_width, precision, flags);
+			continue;
+
+
+		case 'n':
+			if (qualifier == 'l') {
+				long * ip = va_arg(args, long *);
+				*ip = (str - buf);
+			} else {
+				int * ip = va_arg(args, int *);
+				*ip = (str - buf);
+			}
+			continue;
+
+		case '%':
+			*str++ = '%';
+			continue;
+
+		/* integer number formats - set up the flags and "break" */
+		case 'o':
+			base = 8;
+			break;
+
+		case 'X':
+			flags |= LARGE;
+		case 'x':
+			base = 16;
+			break;
+
+		case 'd':
+		case 'i':
+			flags |= SIGN;
+		case 'u':
+			break;
+
+		default:
+			*str++ = '%';
+			if (*fmt)
+				*str++ = *fmt;
+			else
+				--fmt;
+			continue;
+		}
+#ifdef CFG_64BIT_VSPRINTF
+		if (qualifier == 'q')  /* "quad" for 64 bit variables */
+			num = va_arg(args, unsigned long long);
+		else
+#endif
+		if (qualifier == 'l')
+			num = va_arg(args, unsigned long);
+		else if (qualifier == 'h') {
+			num = (unsigned short) va_arg(args, int);
+			if (flags & SIGN)
+				num = (short) num;
+		} else if (flags & SIGN)
+			num = va_arg(args, int);
+		else
+			num = va_arg(args, unsigned int);
+		str = number(str, num, base, field_width, precision, flags);
+	}
+	*str = '\0';
+	return str-buf;
+}
+
+int sprintf(char * buf, const char *fmt, ...)
+{
+	va_list args;
+	int i;
+
+	va_start(args, fmt);
+	i=vsprintf(buf,fmt,args);
+	va_end(args);
+	return i;
+}
+
+void panic(const char *fmt, ...)
+{
+	va_list	args;
+	va_start(args, fmt);
+	vprintf(fmt, args);
+	putc('\n');
+	va_end(args);
+#if defined (CONFIG_PANIC_HANG)
+	hang();
+#else
+	udelay (100000);	/* allow messages to go out */
+	do_reset (NULL, 0, 0, NULL);
+#endif
+}
